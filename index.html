<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#ffffff">
  <link rel="icon" href="https://pfst.cf2.poecdn.net/base/image/2a8f400339a17ba3f803f831a236ad73cda52234db8b2fb53fe6b09cdd42d427?w=1024&h=1024">
  <title>Canvas</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #fff;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }

    /* Dark mode - affects toolbar only, canvas stays white */
    html.dark .toolbar-toggle {
      color: #aaa;
    }

    html.dark .toolbar-toggle:hover {
      color: #ddd;
    }

    #canvas {
      cursor: crosshair;
      touch-action: none;
      display: block;
    }

    .canvas-container {
      width: 100%;
      height: 100%;
      overflow: hidden;
      position: absolute;
      top: 0;
      left: 0;
    }

    /* Minimal toolbar - toggle visibility with button */
    .toolbar {
      position: fixed;
      top: -70px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      padding: 10px 16px;
      background: rgba(245, 245, 245, 0.95);
      border-radius: 0 0 12px 12px;
      backdrop-filter: blur(10px);
      transition: top 0.3s ease, background 0.3s ease;
      z-index: 100;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    html.dark .toolbar {
      background: rgba(30, 30, 30, 0.95);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .toolbar.visible {
      top: 0;
    }

    .btn {
      width: 32px;
      height: 32px;
      border: none;
      border-radius: 6px;
      background: rgba(0, 0, 0, 0.08);
      color: #333;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s, color 0.2s;
      font-size: 16px;
    }

    .btn:hover {
      background: rgba(0, 0, 0, 0.15);
    }

    .btn.active {
      background: rgba(0, 0, 0, 0.2);
    }

    html.dark .btn {
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
    }

    html.dark .btn:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    html.dark .btn.active {
      background: rgba(255, 255, 255, 0.3);
    }

    .color-btn {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: 2px solid transparent;
      cursor: pointer;
      transition: transform 0.15s, border-color 0.15s;
    }

    .color-btn:hover {
      transform: scale(1.15);
    }

    .color-btn.active {
      border-color: #333;
    }

    html.dark .color-btn.active {
      border-color: #fff;
    }

    .separator {
      width: 1px;
      background: rgba(0, 0, 0, 0.15);
      margin: 0 4px;
    }

    html.dark .separator {
      background: rgba(255, 255, 255, 0.2);
    }

    .size-indicator {
      color: rgba(0, 0, 0, 0.6);
      font-size: 11px;
      font-family: system-ui, sans-serif;
      min-width: 28px;
      text-align: center;
      align-self: center;
    }

    html.dark .size-indicator {
      color: rgba(255, 255, 255, 0.7);
    }

    /* Eraser cursor indicator */
    .eraser-cursor {
      position: fixed;
      border: 2px solid rgba(0, 0, 0, 0.5);
      border-radius: 50%;
      pointer-events: none;
      z-index: 1000;
      display: none;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.2);
    }

    .eraser-cursor.visible {
      display: block;
    }

    /* Lasso selection overlay */
    #lassoCanvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 10;
    }

    /* Selection indicator */
    .selection-box {
      position: absolute;
      border: 2px dashed #4a8ea1;
      background: transparent;
      pointer-events: none;
      z-index: 11;
      display: none;
    }

    .selection-box.visible {
      display: block;
    }

    .selection-box.moving {
      cursor: move;
      /* pointer-events stays none - movement handled through canvas */
    }

    /* Rotation handle */
    .rotation-handle {
      position: absolute;
      width: 20px;
      height: 20px;
      background: #4a8ea1;
      border: 2px solid #fff;
      border-radius: 50%;
      cursor: grab;
      pointer-events: none;
      z-index: 12;
      display: none;
      transform: translate(-50%, -50%);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .rotation-handle.visible {
      display: block;
    }

    .rotation-handle:active {
      cursor: grabbing;
    }

    /* Rotation line connecting handle to selection */
    .rotation-line {
      position: absolute;
      width: 2px;
      background: #4a8ea1;
      pointer-events: none;
      z-index: 11;
      display: none;
      transform-origin: bottom center;
    }

    .rotation-line.visible {
      display: block;
    }

    /* Toggle toolbar button */
    .toolbar-toggle {
      position: fixed;
      top: 12px;
      right: 12px;
      width: 32px;
      height: 32px;
      border: none;
      border-radius: 50%;
      background: transparent;
      color: #555;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 101;
      transition: color 0.2s;
    }

    .toolbar-toggle:hover {
      color: #333;
    }

    .toolbar-toggle:active {
      color: #555;
    }

    html.dark .toolbar-toggle:active {
      color: #aaa;
    }

    .toolbar-toggle svg {
      width: 30px;
      height: 30px;
    }

  </style>
</head>
<body>
  <div class="canvas-container">
    <canvas id="canvas"></canvas>
    <canvas id="lassoCanvas"></canvas>
    <div class="selection-box" id="selectionBox"></div>
    <div class="rotation-line" id="rotationLine"></div>
    <div class="rotation-handle" id="rotationHandle"></div>
  </div>
  <div class="eraser-cursor" id="eraserCursor"></div>

  <button class="toolbar-toggle" id="toolbarToggle" title="Toggle toolbar">
    <svg id="toggleIconCircle" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="0.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/></svg>
    <svg id="toggleIconLock" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="0.5" stroke-linecap="round" stroke-linejoin="round" style="display:none;"><circle cx="12" cy="16" r="1"/><rect x="3" y="10" width="18" height="12" rx="2"/><path d="M7 10V7a5 5 0 0 1 10 0v3"/></svg>
  </button>

  <div class="toolbar" id="toolbar">
    <!-- Colors -->
    <button class="color-btn active" style="background: #1a1a1a;" data-color="#1a1a1a" title="Black"></button>
    <button class="color-btn" style="background: #e74c3c;" data-color="#e74c3c" title="Red"></button>
    <button class="color-btn" style="background: #3498db;" data-color="#3498db" title="Blue"></button>
    <button class="color-btn" style="background: #27ae60;" data-color="#27ae60" title="Green"></button>

    <div class="separator"></div>

    <!-- Size controls -->
    <button class="btn" id="sizeDown" title="Smaller">−</button>
    <span class="size-indicator" id="sizeDisplay">1.5</span>
    <button class="btn" id="sizeUp" title="Larger">+</button>

    <div class="separator"></div>

    <!-- Tools -->
    <button class="btn" id="eraserBtn" title="Eraser">⌫</button>
    <button class="btn" id="clearBtn" title="Clear All">✕</button>

    <div class="separator"></div>

    <button class="btn" id="fullscreenBtn" title="Toggle Fullscreen">
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3"/><path d="M21 8V5a2 2 0 0 0-2-2h-3"/><path d="M3 16v3a2 2 0 0 0 2 2h3"/><path d="M16 21h3a2 2 0 0 0 2-2v-3"/></svg>
    </button>
    <button class="btn" id="themeBtn" title="Toggle Dark/Light Mode">
      <svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></svg>
      <svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display:none;"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>
    </button>
  </div>

  <script>
    // Dark/Light mode detection and toggle
    const sunIcon = document.getElementById('sunIcon');
    const moonIcon = document.getElementById('moonIcon');

    function updateThemeIcons() {
      const isDark = document.documentElement.classList.contains('dark');
      sunIcon.style.display = isDark ? 'none' : 'block';
      moonIcon.style.display = isDark ? 'block' : 'none';
    }

    // Detect user's preferred color scheme
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      document.documentElement.classList.add('dark');
    }
    updateThemeIcons();

    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
      if (event.matches) {
        document.documentElement.classList.add('dark');
      } else {
        document.documentElement.classList.remove('dark');
      }
      updateThemeIcons();
    });

    document.getElementById('themeBtn').addEventListener('click', () => {
      document.documentElement.classList.toggle('dark');
      updateThemeIcons();
    });

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', {
      willReadFrequently: false,
      desynchronized: true
    });

    // State
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    let lastPressure = 0.5;
    let strokeColor = '#1a1a1a';
    let baseSize = 1.5;
    let isEraser = false;
    let activeEraser = false; // True during stroke if using eraser tip or eraser tool

    // Double-tap eraser boost
    let eraserSizeMultiplier = 1;
    let eraserTapCount = 0;
    let lastEraserLiftTime = 0;
    let eraserResetTimeout = null;
    const DOUBLE_TAP_THRESHOLD = 150; // ms between taps to count as double-tap

    // Eraser cursor indicator
    const eraserCursor = document.getElementById('eraserCursor');

    // Lasso tool state
    const lassoCanvas = document.getElementById('lassoCanvas');
    const lassoCtx = lassoCanvas.getContext('2d');
    const selectionBox = document.getElementById('selectionBox');
    const rotationHandle = document.getElementById('rotationHandle');
    const rotationLine = document.getElementById('rotationLine');
    let isLassoMode = false;
    let isLassoDrawing = false;
    let lassoPath = []; // Array of {x, y} points
    let hasSelection = false;
    let selectionImageData = null;
    let selectionBounds = null; // {x, y, width, height}
    let isMovingSelection = false;
    let isRotatingSelection = false;
    let moveStartX = 0;
    let moveStartY = 0;
    let selectionOffsetX = 0;
    let selectionOffsetY = 0;
    let selectionRotation = 0; // Rotation angle in radians
    const ROTATION_HANDLE_DISTANCE = 40; // Distance of handle from selection top

    // Detect stylus barrel button (button 2 / right click on pen)
    function isBarrelButton(e) {
      return e.button === 2 || (e.buttons & 2) !== 0;
    }

    function updateEraserCursor(x, y, show) {
      if (show) {
        const size = (getStrokeWidth(0.5) + 10) * 2 * eraserSizeMultiplier;
        eraserCursor.style.width = size + 'px';
        eraserCursor.style.height = size + 'px';
        eraserCursor.style.left = x + 'px';
        eraserCursor.style.top = y + 'px';
        eraserCursor.classList.add('visible');
        // Change border color when boosted
        eraserCursor.style.borderColor = eraserSizeMultiplier > 1 ? 'rgba(255, 100, 100, 0.8)' : 'rgba(0, 0, 0, 0.5)';
      } else {
        eraserCursor.classList.remove('visible');
      }
    }

    // Fixed canvas size with High DPI support
    function initCanvas() {
      const dpr = window.devicePixelRatio || 1;
      // Use initial viewport size as fixed canvas size
      const width = window.innerWidth;
      const height = window.innerHeight;

      canvas.width = width * dpr;
      canvas.height = height * dpr;

      ctx.scale(dpr, dpr);
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';

      // Canvas is transparent - white background handled by CSS
      ctx.clearRect(0, 0, width, height);
    }

    initCanvas();

    // Handle fullscreen changes - resize canvas to match viewport size while preserving content
    function handleFullscreenChange() {
      const dpr = window.devicePixelRatio || 1;
      const newWidth = window.innerWidth;
      const newHeight = window.innerHeight;

      // Save current canvas content
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

      // Resize canvas to new viewport size
      canvas.width = newWidth * dpr;
      canvas.height = newHeight * dpr;
      ctx.scale(dpr, dpr);
      canvas.style.width = newWidth + 'px';
      canvas.style.height = newHeight + 'px';

      // Restore content
      ctx.putImageData(imageData, 0, 0);

      // Also resize lasso canvas
      lassoCanvas.width = newWidth * dpr;
      lassoCanvas.height = newHeight * dpr;
      lassoCtx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
      lassoCtx.scale(dpr, dpr);
      lassoCanvas.style.width = newWidth + 'px';
      lassoCanvas.style.height = newHeight + 'px';
    }

    document.addEventListener('fullscreenchange', handleFullscreenChange);
    document.addEventListener('webkitfullscreenchange', handleFullscreenChange);

    // Initialize lasso canvas to same size
    function initLassoCanvas() {
      const dpr = window.devicePixelRatio || 1;
      const width = parseInt(canvas.style.width);
      const height = parseInt(canvas.style.height);
      lassoCanvas.width = width * dpr;
      lassoCanvas.height = height * dpr;
      lassoCtx.scale(dpr, dpr);
      lassoCanvas.style.width = width + 'px';
      lassoCanvas.style.height = height + 'px';
    }
    initLassoCanvas();

    // Clear lasso overlay
    function clearLassoCanvas() {
      const width = parseInt(lassoCanvas.style.width);
      const height = parseInt(lassoCanvas.style.height);
      lassoCtx.clearRect(0, 0, width, height);
    }

    // Draw lasso path on overlay
    function drawLassoPath() {
      clearLassoCanvas();
      if (lassoPath.length < 2) return;

      lassoCtx.beginPath();
      lassoCtx.moveTo(lassoPath[0].x, lassoPath[0].y);
      for (let i = 1; i < lassoPath.length; i++) {
        lassoCtx.lineTo(lassoPath[i].x, lassoPath[i].y);
      }
      lassoCtx.strokeStyle = '#4a8ea1';
      lassoCtx.lineWidth = 2;
      lassoCtx.setLineDash([5, 5]);
      lassoCtx.stroke();
      lassoCtx.setLineDash([]);
    }

    // Get bounding box of lasso path
    function getLassoBounds() {
      if (lassoPath.length === 0) return null;
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (const p of lassoPath) {
        minX = Math.min(minX, p.x);
        minY = Math.min(minY, p.y);
        maxX = Math.max(maxX, p.x);
        maxY = Math.max(maxY, p.y);
      }
      return {
        x: Math.floor(minX),
        y: Math.floor(minY),
        width: Math.ceil(maxX - minX),
        height: Math.ceil(maxY - minY)
      };
    }

    // Create selection from lasso path
    function createSelection() {
      if (lassoPath.length < 3) {
        cancelSelection();
        return;
      }

      const bounds = getLassoBounds();
      if (!bounds || bounds.width < 5 || bounds.height < 5) {
        cancelSelection();
        return;
      }

      selectionBounds = bounds;
      const dpr = window.devicePixelRatio || 1;

      // Create a temporary canvas at full DPR resolution to preserve quality
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = bounds.width * dpr;
      tempCanvas.height = bounds.height * dpr;
      const tempCtx = tempCanvas.getContext('2d');

      // Scale context for DPR
      tempCtx.scale(dpr, dpr);

      // Create clipping path from lasso (in local CSS coordinates)
      tempCtx.beginPath();
      tempCtx.moveTo(lassoPath[0].x - bounds.x, lassoPath[0].y - bounds.y);
      for (let i = 1; i < lassoPath.length; i++) {
        tempCtx.lineTo(lassoPath[i].x - bounds.x, lassoPath[i].y - bounds.y);
      }
      tempCtx.closePath();
      tempCtx.clip();

      // Draw the main canvas content into the clipped area
      // Source is in actual canvas pixels (scaled by DPR), dest is in CSS pixels (but context is scaled)
      tempCtx.drawImage(
        canvas,
        bounds.x * dpr, bounds.y * dpr, bounds.width * dpr, bounds.height * dpr,
        0, 0, bounds.width, bounds.height
      );

      // Store the selection image
      selectionImageData = tempCanvas;

      // Clear the selected area from main canvas using the lasso path
      ctx.save();
      ctx.globalCompositeOperation = 'destination-out';
      ctx.beginPath();
      ctx.moveTo(lassoPath[0].x, lassoPath[0].y);
      for (let i = 1; i < lassoPath.length; i++) {
        ctx.lineTo(lassoPath[i].x, lassoPath[i].y);
      }
      ctx.closePath();
      ctx.fill();
      ctx.restore();

      // Show selection box
      selectionBox.style.left = bounds.x + 'px';
      selectionBox.style.top = bounds.y + 'px';
      selectionBox.style.width = bounds.width + 'px';
      selectionBox.style.height = bounds.height + 'px';
      selectionBox.classList.add('visible', 'moving');

      hasSelection = true;
      selectionOffsetX = 0;
      selectionOffsetY = 0;

      // Draw selection preview on lasso canvas
      drawSelectionPreview();

      // Clear lasso path display
      lassoPath = [];
    }

    // Get selection center point
    function getSelectionCenter() {
      if (!selectionBounds) return { x: 0, y: 0 };
      return {
        x: selectionBounds.x + selectionOffsetX + selectionBounds.width / 2,
        y: selectionBounds.y + selectionOffsetY + selectionBounds.height / 2
      };
    }

    // Update rotation handle and line position
    function updateRotationHandlePosition() {
      if (!hasSelection || !selectionBounds) {
        rotationHandle.classList.remove('visible');
        rotationLine.classList.remove('visible');
        return;
      }

      const center = getSelectionCenter();

      // Position handle above selection, accounting for rotation
      const handleX = center.x + Math.sin(selectionRotation) * (selectionBounds.height / 2 + ROTATION_HANDLE_DISTANCE);
      const handleY = center.y - Math.cos(selectionRotation) * (selectionBounds.height / 2 + ROTATION_HANDLE_DISTANCE);

      rotationHandle.style.left = handleX + 'px';
      rotationHandle.style.top = handleY + 'px';
      rotationHandle.classList.add('visible');

      // Position and rotate the line connecting handle to selection
      const lineLength = ROTATION_HANDLE_DISTANCE;
      rotationLine.style.height = lineLength + 'px';
      rotationLine.style.left = center.x + 'px';
      rotationLine.style.top = (center.y - selectionBounds.height / 2 - lineLength) + 'px';
      rotationLine.style.transform = `translateX(-50%) rotate(${selectionRotation}rad)`;
      rotationLine.style.transformOrigin = `center ${lineLength + selectionBounds.height / 2}px`;
      rotationLine.classList.add('visible');
    }

    // Draw selection preview on lasso canvas
    function drawSelectionPreview() {
      if (!hasSelection || !selectionImageData || !selectionBounds) return;

      clearLassoCanvas();
      const center = getSelectionCenter();

      // Save context state
      lassoCtx.save();

      // Translate to center, rotate, then draw
      lassoCtx.translate(center.x, center.y);
      lassoCtx.rotate(selectionRotation);
      lassoCtx.translate(-selectionBounds.width / 2, -selectionBounds.height / 2);

      // Draw the DPR-scaled selection image
      lassoCtx.drawImage(
        selectionImageData,
        0, 0, selectionImageData.width, selectionImageData.height,
        0, 0, selectionBounds.width, selectionBounds.height
      );

      // Restore context state
      lassoCtx.restore();

      // Update rotation handle position
      updateRotationHandlePosition();

      // Update selection box with rotation
      selectionBox.style.left = (selectionBounds.x + selectionOffsetX) + 'px';
      selectionBox.style.top = (selectionBounds.y + selectionOffsetY) + 'px';
      selectionBox.style.transform = `rotate(${selectionRotation}rad)`;
      selectionBox.style.transformOrigin = 'center center';
    }

    // Commit selection to main canvas
    function commitSelection() {
      if (!hasSelection || !selectionImageData || !selectionBounds) return;

      const center = getSelectionCenter();

      ctx.globalCompositeOperation = 'source-over';

      // Save context state
      ctx.save();

      // Translate to center, rotate, then draw
      ctx.translate(center.x, center.y);
      ctx.rotate(selectionRotation);
      ctx.translate(-selectionBounds.width / 2, -selectionBounds.height / 2);

      // Draw DPR-scaled selection back to main canvas
      ctx.drawImage(
        selectionImageData,
        0, 0, selectionImageData.width, selectionImageData.height,
        0, 0, selectionBounds.width, selectionBounds.height
      );

      // Restore context state
      ctx.restore();

      cancelSelection();
    }

    // Cancel/clear selection
    function cancelSelection() {
      hasSelection = false;
      selectionImageData = null;
      selectionBounds = null;
      lassoPath = [];
      selectionOffsetX = 0;
      selectionOffsetY = 0;
      selectionRotation = 0;
      selectionBox.classList.remove('visible', 'moving');
      selectionBox.style.transform = '';
      rotationHandle.classList.remove('visible');
      rotationLine.classList.remove('visible');
      clearLassoCanvas();
    }

    // Start lasso drawing
    function startLasso(e) {
      // If we have a selection, commit it first before starting new lasso
      if (hasSelection) {
        commitSelection();
      }

      isLassoDrawing = true;
      lassoPath = [];
      const pos = getPointerPos(e);
      lassoPath.push({ x: pos.x, y: pos.y });
      drawLassoPath();
    }

    // Continue lasso drawing
    function continueLasso(e) {
      if (!isLassoDrawing) return;

      const pos = getPointerPos(e);
      lassoPath.push({ x: pos.x, y: pos.y });
      drawLassoPath();
    }

    // End lasso drawing
    function endLasso() {
      if (!isLassoDrawing) return;
      isLassoDrawing = false;

      // Create selection from path
      createSelection();
    }

    // Tilt compensation factor (pixels per degree of tilt)
    // Adjust this value based on stylus geometry - higher values = more compensation
    const TILT_COMPENSATION = 0.04;

    function getPointerPos(e) {
      const rect = canvas.getBoundingClientRect();
      let x = e.clientX - rect.left;
      let y = e.clientY - rect.top;

      // Apply tilt compensation if tilt data is available
      // tiltX and tiltY are in degrees (-90 to 90)
      if (e.pointerType === 'pen' && typeof e.tiltX === 'number' && typeof e.tiltY === 'number') {
        // Compensate position based on tilt angle
        // When tilted, offset the position opposite to the tilt direction
        x -= e.tiltX * TILT_COMPENSATION;
        y -= e.tiltY * TILT_COMPENSATION;
      }

      return {
        x: x,
        y: y,
        pressure: e.pressure || 0.5
      };
    }

    // Detect if using eraser end of stylus (button 5 or buttons bitmask 32)
    function isEraserTip(e) {
      return e.button === 5 || (e.buttons & 32) !== 0;
    }

    // Check if point is near the rotation handle
    function isNearRotationHandle(pos) {
      if (!hasSelection || !selectionBounds) return false;

      const center = getSelectionCenter();
      const handleX = center.x + Math.sin(selectionRotation) * (selectionBounds.height / 2 + ROTATION_HANDLE_DISTANCE);
      const handleY = center.y - Math.cos(selectionRotation) * (selectionBounds.height / 2 + ROTATION_HANDLE_DISTANCE);

      const dx = pos.x - handleX;
      const dy = pos.y - handleY;
      const distance = Math.sqrt(dx * dx + dy * dy);

      return distance < 25; // 25px hit area for the handle
    }

    // Check if point is inside the rotated selection box
    function isInsideRotatedSelection(pos) {
      if (!hasSelection || !selectionBounds) return false;

      const center = getSelectionCenter();

      // Rotate the point back to unrotated space
      const dx = pos.x - center.x;
      const dy = pos.y - center.y;
      const cos = Math.cos(-selectionRotation);
      const sin = Math.sin(-selectionRotation);
      const rotatedX = dx * cos - dy * sin + center.x;
      const rotatedY = dx * sin + dy * cos + center.y;

      // Check if in bounds
      const x = selectionBounds.x + selectionOffsetX;
      const y = selectionBounds.y + selectionOffsetY;

      return rotatedX >= x && rotatedX <= x + selectionBounds.width &&
             rotatedY >= y && rotatedY <= y + selectionBounds.height;
    }

    function startStroke(e) {
      // Only allow pen (stylus) input - disable finger/touch
      if (e.pointerType === 'touch') return;

      // If we have an active selection, check for rotation handle, inside, or outside
      if (hasSelection && selectionBounds) {
        const pos = getPointerPos(e);

        // Check rotation handle first
        if (isNearRotationHandle(pos)) {
          isRotatingSelection = true;
          moveStartX = pos.x;
          moveStartY = pos.y;
          e.preventDefault();
          return;
        }

        // Check if inside selection (accounting for rotation)
        if (isInsideRotatedSelection(pos)) {
          // Touch inside selection - start moving
          isMovingSelection = true;
          moveStartX = pos.x;
          moveStartY = pos.y;
          e.preventDefault();
          return;
        } else {
          // Touch outside selection - commit it only, don't start a stroke
          commitSelection();
          e.preventDefault();
          return;
        }
      }

      // Check for barrel button - activate lasso mode
      if (isBarrelButton(e)) {
        isLassoMode = true;
        startLasso(e);
        e.preventDefault();
        return;
      }

      isDrawing = true;
      activeEraser = isEraser || isEraserTip(e); // Use eraser if tool selected OR using eraser tip

      const pos = getPointerPos(e);
      lastX = pos.x;
      lastY = pos.y;
      lastPressure = pos.pressure;
      smoothedPressure = pos.pressure; // Reset smoothed pressure for new stroke
      isFirstSegment = true; // Reset for smooth curve connections
      resetStabilization(); // Reset stabilization buffer for new stroke

      // Show eraser cursor
      updateEraserCursor(e.clientX, e.clientY, activeEraser);

      // Double-tap detection for eraser boost
      if (activeEraser) {
        // Clear any pending reset
        if (eraserResetTimeout) {
          clearTimeout(eraserResetTimeout);
          eraserResetTimeout = null;
        }

        const now = Date.now();
        const timeSinceLastLift = now - lastEraserLiftTime;

        // If this tap is within threshold of last lift, count it
        if (timeSinceLastLift < DOUBLE_TAP_THRESHOLD && lastEraserLiftTime > 0) {
          eraserTapCount++;
          // Boost eraser on triple-tap
          if (eraserTapCount >= 3 && eraserSizeMultiplier === 1) {
            eraserSizeMultiplier = 4;
            updateEraserCursor(e.clientX, e.clientY, true); // Update cursor size
          }
        } else {
          // Too slow, reset tap count (but keep multiplier if already boosted)
          eraserTapCount = 1;
        }
      }

      // Set composite operation for eraser (destination-out removes pixels)
      if (activeEraser) {
        ctx.globalCompositeOperation = 'destination-out';
      } else {
        ctx.globalCompositeOperation = 'source-over';
      }

      ctx.beginPath();
      ctx.arc(pos.x, pos.y, getStrokeWidth(pos.pressure) / 2, 0, Math.PI * 2);
      ctx.fillStyle = activeEraser ? 'rgba(0,0,0,1)' : strokeColor;
      ctx.fill();
    }

    // Pressure smoothing factor (0-1, higher = more smoothing)
    const PRESSURE_SMOOTHING = 0.3;
    let smoothedPressure = 0.5;

    // Stroke stabilization - moving average buffer
    const STABILIZATION_LEVEL = 6; // Number of points to average (higher = smoother but more lag)
    let stabilizationBuffer = [];

    function getStabilizedPoint(x, y, pressure) {
      // Add new point to buffer
      stabilizationBuffer.push({ x, y, pressure });

      // Keep buffer at max size
      if (stabilizationBuffer.length > STABILIZATION_LEVEL) {
        stabilizationBuffer.shift();
      }

      // Calculate weighted average (more recent points have higher weight)
      let totalWeight = 0;
      let avgX = 0;
      let avgY = 0;
      let avgPressure = 0;

      for (let i = 0; i < stabilizationBuffer.length; i++) {
        const weight = i + 1; // Linear weight: 1, 2, 3, ...
        avgX += stabilizationBuffer[i].x * weight;
        avgY += stabilizationBuffer[i].y * weight;
        avgPressure += stabilizationBuffer[i].pressure * weight;
        totalWeight += weight;
      }

      return {
        x: avgX / totalWeight,
        y: avgY / totalWeight,
        pressure: avgPressure / totalWeight
      };
    }

    function resetStabilization() {
      stabilizationBuffer = [];
    }

    // Track previous midpoint for smooth curve connections
    let prevMidX = 0;
    let prevMidY = 0;
    let isFirstSegment = true;

    // Predictive stroke - tracks raw position for preview
    let lastRawX = 0;
    let lastRawY = 0;
    let lastRawPressure = 0.5;

    // Draw predictive preview line on lasso canvas (temporary, gets overwritten)
    function drawPredictivePreview(stabilizedX, stabilizedY, rawX, rawY, pressure) {
      // Only draw if there's meaningful distance between stabilized and raw position
      const dx = rawX - stabilizedX;
      const dy = rawY - stabilizedY;
      const distance = Math.sqrt(dx * dx + dy * dy);

      // Clear previous preview
      clearLassoCanvas();

      if (distance > 2 && !activeEraser) {
        const width = getStrokeWidth(pressure);

        lassoCtx.beginPath();
        lassoCtx.strokeStyle = strokeColor;
        lassoCtx.lineWidth = width;
        lassoCtx.lineCap = 'round';
        lassoCtx.lineJoin = 'round';
        lassoCtx.globalAlpha = 0.5; // Semi-transparent preview
        lassoCtx.moveTo(stabilizedX, stabilizedY);
        lassoCtx.lineTo(rawX, rawY);
        lassoCtx.stroke();
        lassoCtx.globalAlpha = 1.0;
      }
    }

    // Clear predictive preview
    function clearPredictivePreview() {
      if (!hasSelection && !isLassoDrawing) {
        clearLassoCanvas();
      }
    }

    function drawSmoothSegment(fromX, fromY, toX, toY, fromPressure, toPressure) {
      // Calculate midpoint for quadratic curve
      const midX = (fromX + toX) / 2;
      const midY = (fromY + toY) / 2;

      // Smooth pressure
      smoothedPressure = smoothedPressure * PRESSURE_SMOOTHING + toPressure * (1 - PRESSURE_SMOOTHING);

      const fromWidth = getStrokeWidth(fromPressure);
      const toWidth = getStrokeWidth(smoothedPressure);

      ctx.beginPath();
      ctx.strokeStyle = activeEraser ? 'rgba(0,0,0,1)' : strokeColor;
      ctx.lineWidth = activeEraser ? ((fromWidth + toWidth) / 2 + 10) * 2 * eraserSizeMultiplier : (fromWidth + toWidth) / 2;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      if (isFirstSegment) {
        // First segment: draw line from start to midpoint
        ctx.moveTo(fromX, fromY);
        ctx.lineTo(midX, midY);
        isFirstSegment = false;
      } else {
        // Subsequent segments: draw curve from previous midpoint through current point to new midpoint
        ctx.moveTo(prevMidX, prevMidY);
        ctx.quadraticCurveTo(fromX, fromY, midX, midY);
      }

      ctx.stroke();

      // Store midpoint for next segment
      prevMidX = midX;
      prevMidY = midY;
    }

    function continueStroke(e) {
      // Handle rotating selection
      if (isRotatingSelection && hasSelection) {
        const pos = getPointerPos(e);
        const center = getSelectionCenter();

        // Calculate angle from center to current position
        const currentAngle = Math.atan2(pos.x - center.x, -(pos.y - center.y));

        // Calculate angle from center to start position
        const startAngle = Math.atan2(moveStartX - center.x, -(moveStartY - center.y));

        // Update rotation
        selectionRotation += currentAngle - startAngle;

        moveStartX = pos.x;
        moveStartY = pos.y;

        drawSelectionPreview();
        return;
      }

      // Handle moving selection (can happen outside of lasso mode now)
      if (isMovingSelection && hasSelection) {
        const pos = getPointerPos(e);
        const dx = pos.x - moveStartX;
        const dy = pos.y - moveStartY;
        selectionOffsetX += dx;
        selectionOffsetY += dy;
        moveStartX = pos.x;
        moveStartY = pos.y;

        // Update selection box position
        selectionBox.style.left = (selectionBounds.x + selectionOffsetX) + 'px';
        selectionBox.style.top = (selectionBounds.y + selectionOffsetY) + 'px';

        drawSelectionPreview();
        return;
      }

      // Handle lasso drawing mode
      if (isLassoMode) {
        continueLasso(e);
        return;
      }

      if (!isDrawing) return;

      // Update eraser cursor position
      updateEraserCursor(e.clientX, e.clientY, activeEraser);

      // Keep eraser boosted while actively erasing - cancel any pending reset
      if (activeEraser && eraserResetTimeout) {
        clearTimeout(eraserResetTimeout);
        eraserResetTimeout = null;
      }

      // Use coalesced events for smoother strokes (captures intermediate points)
      const events = e.getCoalescedEvents ? e.getCoalescedEvents() : [e];

      for (const coalescedEvent of events) {
        const rawPos = getPointerPos(coalescedEvent);

        // Apply stabilization to smooth out hand jitter
        const pos = getStabilizedPoint(rawPos.x, rawPos.y, rawPos.pressure);

        // Draw smooth segment using quadratic Bezier curve
        drawSmoothSegment(lastX, lastY, pos.x, pos.y, lastPressure, pos.pressure);

        lastX = pos.x;
        lastY = pos.y;
        lastPressure = pos.pressure;

        // Track raw position for predictive preview
        lastRawX = rawPos.x;
        lastRawY = rawPos.y;
        lastRawPressure = rawPos.pressure;
      }

      // Draw predictive preview from stabilized to raw position
      drawPredictivePreview(lastX, lastY, lastRawX, lastRawY, lastRawPressure);
    }

    function endStroke(scheduleReset = true) {
      // Handle end of rotating selection
      if (isRotatingSelection) {
        isRotatingSelection = false;
        // Selection stays active - user can rotate again or touch outside to commit
        return;
      }

      // Handle end of moving selection
      if (isMovingSelection) {
        isMovingSelection = false;
        // Selection stays active - user can move again or touch outside to commit
        return;
      }

      // Handle lasso mode end
      if (isLassoMode) {
        endLasso();
        isLassoMode = false;
        return;
      }

      // Track eraser lift time and schedule reset
      if (activeEraser && scheduleReset) {
        lastEraserLiftTime = Date.now();

        // Schedule reset after threshold - if no new tap comes, reset everything
        eraserResetTimeout = setTimeout(() => {
          eraserSizeMultiplier = 1;
          eraserTapCount = 0;
          eraserResetTimeout = null;
        }, DOUBLE_TAP_THRESHOLD);
      }

      isDrawing = false;
      updateEraserCursor(0, 0, false); // Hide eraser cursor
      clearPredictivePreview(); // Clear the preview line
    }

    function getStrokeWidth(pressure) {
      const minWidth = baseSize * 0.3;
      const maxWidth = baseSize * 2.5;
      return minWidth + (maxWidth - minWidth) * pressure;
    }

    canvas.addEventListener('pointerdown', startStroke);
    canvas.addEventListener('pointermove', (e) => {
      continueStroke(e);
      // Show eraser cursor on hover when eraser tool is selected
      if (!isDrawing && (isEraser || isEraserTip(e))) {
        updateEraserCursor(e.clientX, e.clientY, true);
      } else if (!isDrawing) {
        updateEraserCursor(0, 0, false);
      }
    });
    canvas.addEventListener('pointerup', () => endStroke(true));
    canvas.addEventListener('pointerleave', () => {
      endStroke(false); // Don't schedule reset on leave - only on actual lift
      updateEraserCursor(0, 0, false); // Hide cursor when leaving canvas
    });
    canvas.addEventListener('pointercancel', () => endStroke(false));

    canvas.addEventListener('touchstart', e => e.preventDefault(), { passive: false });
    canvas.addEventListener('touchmove', e => e.preventDefault(), { passive: false });

    // Prevent context menu on right-click (barrel button)
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    // Toolbar
    const toolbar = document.getElementById('toolbar');
    const colorBtns = document.querySelectorAll('.color-btn');
    const sizeDisplay = document.getElementById('sizeDisplay');
    const eraserBtn = document.getElementById('eraserBtn');

    colorBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        colorBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        strokeColor = btn.dataset.color;
        isEraser = false;
        eraserBtn.classList.remove('active');
      });
    });

    document.getElementById('sizeUp').addEventListener('click', () => {
      baseSize = Math.min(20, baseSize + 0.5);
      sizeDisplay.textContent = baseSize % 1 === 0 ? baseSize : baseSize.toFixed(1);
    });

    document.getElementById('sizeDown').addEventListener('click', () => {
      baseSize = Math.max(0.5, baseSize - 0.5);
      sizeDisplay.textContent = baseSize % 1 === 0 ? baseSize : baseSize.toFixed(1);
    });

    eraserBtn.addEventListener('click', () => {
      isEraser = !isEraser;
      eraserBtn.classList.toggle('active', isEraser);
      if (isEraser) {
        colorBtns.forEach(b => b.classList.remove('active'));
      } else {
        document.querySelector(`[data-color="${strokeColor}"]`)?.classList.add('active');
      }
    });

    document.getElementById('clearBtn').addEventListener('click', () => {
      const rect = canvas.getBoundingClientRect();
      ctx.globalCompositeOperation = 'source-over';
      ctx.clearRect(0, 0, rect.width, rect.height);
    });

    document.getElementById('fullscreenBtn').addEventListener('click', () => {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(() => {});
      } else {
        document.exitFullscreen().catch(() => {});
      }
    });

    toolbar.addEventListener('pointerdown', e => e.stopPropagation());

    // Toolbar toggle button with three states: hidden, visible, locked
    let toolbarLocked = false;
    const toolbarToggle = document.getElementById('toolbarToggle');
    const toggleIconCircle = document.getElementById('toggleIconCircle');
    const toggleIconLock = document.getElementById('toggleIconLock');

    function updateToggleIcon() {
      if (toolbarLocked) {
        toggleIconCircle.style.display = 'none';
        toggleIconLock.style.display = 'block';
      } else {
        toggleIconCircle.style.display = 'block';
        toggleIconLock.style.display = 'none';
      }
    }

    toolbarToggle.addEventListener('click', () => {
      if (!toolbar.classList.contains('visible')) {
        // Hidden -> Visible
        toolbar.classList.add('visible');
        toolbarLocked = false;
      } else if (!toolbarLocked) {
        // Visible -> Locked
        toolbarLocked = true;
      } else {
        // Locked -> Hidden
        toolbar.classList.remove('visible');
        toolbarLocked = false;
      }
      updateToggleIcon();
    });
    toolbarToggle.addEventListener('pointerdown', e => e.stopPropagation());

    // Close toolbar when touching outside (only if not locked)
    document.addEventListener('pointerdown', (e) => {
      if (toolbar.classList.contains('visible') &&
          !toolbarLocked &&
          !toolbar.contains(e.target) &&
          e.target !== toolbarToggle &&
          !toolbarToggle.contains(e.target)) {
        toolbar.classList.remove('visible');
      }
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', e => {
      if (e.key === 'Escape') {
        // Cancel selection or lasso
        if (hasSelection) {
          // Put selection back at original position
          selectionOffsetX = 0;
          selectionOffsetY = 0;
          commitSelection();
        } else if (isLassoDrawing) {
          isLassoDrawing = false;
          isLassoMode = false;
          cancelSelection();
        }
      } else if (e.key === 'e' || e.key === 'E') {
        eraserBtn.click();
      } else if (e.key === 'c' || e.key === 'C') {
        document.getElementById('clearBtn').click();
      } else if (e.key === '[') {
        document.getElementById('sizeDown').click();
      } else if (e.key === ']') {
        document.getElementById('sizeUp').click();
      } else if (e.key >= '1' && e.key <= '4') {
        const idx = parseInt(e.key) - 1;
        if (colorBtns[idx]) colorBtns[idx].click();
      } else if (e.key === 'Enter' && hasSelection) {
        // Commit selection on Enter
        commitSelection();
      }
    });
  </script>
</body>
</html>
