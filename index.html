<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Vector Canvas</title>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.min.mjs" type="module"></script>
  <style>
    :root { --bg: #fff; --border: #e5e7eb; --btn: #f3f4f6; --btn-hover: #e5e7eb; --active: #3b82f6; --text: #1f2937; --text2: #6b7280; }
    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html, body { width: 100%; height: 100%; overflow: hidden; font-family: 'IBM Plex Sans', -apple-system, sans-serif; background: var(--bg); touch-action: none; }

    /* Hover zone at top of screen */
    .toolbar-hover-zone { position: fixed; top: 0; left: 0; right: 0; height: 40px; z-index: 999; }

    /* Unified toolbar */
    .toolbar { position: fixed; top: 8px; left: 50%; transform: translateX(-50%); display: flex; align-items: center; gap: 4px; padding: 5px 8px; background: var(--bg); border: 1px solid var(--border); border-radius: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); z-index: 1000; transition: opacity 0.3s, transform 0.3s; }
    .toolbar.hidden { opacity: 0; transform: translateX(-50%) translateY(-100%); pointer-events: none; }

    .divider { width: 1px; height: 22px; background: var(--border); margin: 0 3px; }
    .tool-btn { width: 28px; height: 28px; border: none; background: var(--btn); border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s; }
    .tool-btn:hover { background: var(--btn-hover); }
    .tool-btn.active { background: var(--active); }
    .tool-btn.active svg { stroke: #fff; }
    .tool-btn svg { width: 14px; height: 14px; stroke: var(--text); stroke-width: 2; fill: none; }
    .stepper { display: flex; align-items: center; background: var(--btn); border-radius: 6px; overflow: hidden; }
    .stepper-btn { width: 22px; height: 22px; border: none; background: transparent; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: 600; color: var(--text); transition: background 0.15s; }
    .stepper-btn:hover { background: var(--btn-hover); }
    .stepper-btn:active { background: #d1d5db; }
    .stepper-value { min-width: 26px; text-align: center; font-size: 11px; font-weight: 600; padding: 0 2px; cursor: pointer; border-radius: 4px; transition: background 0.15s; }
    .stepper-value:hover { background: var(--btn-hover); }
    .color-modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center; z-index: 2000; opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s; }
    .color-modal-overlay.visible { opacity: 1; visibility: visible; }
    .color-modal { background: var(--bg); border-radius: 16px; padding: 20px; box-shadow: 0 8px 32px rgba(0,0,0,0.15); transform: scale(0.9); transition: transform 0.2s; }
    .color-modal-overlay.visible .color-modal { transform: scale(1); }
    .color-modal-title { font-size: 14px; font-weight: 600; color: var(--text); margin-bottom: 16px; text-align: center; }
    .color-modal-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 12px; }
    .color-modal-btn { width: 40px; height: 40px; border: 3px solid transparent; border-radius: 50%; cursor: pointer; transition: transform 0.15s, border-color 0.15s, box-shadow 0.15s; }
    .color-modal-btn:hover { transform: scale(1.15); box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
    .color-modal-btn.selected { border-color: var(--active); }
    .canvas-container { width: 100%; height: 100%; overflow: hidden; cursor: crosshair; position: relative; }
    .canvas-container.pdf-mode { overflow-y: auto; overflow-x: hidden; background: #fff; display: flex; flex-direction: column; align-items: center; scrollbar-width: thin; scrollbar-color: rgba(0,0,0,0.2) transparent; }
    .canvas-container.pdf-mode::-webkit-scrollbar { width: 6px; }
    .canvas-container.pdf-mode::-webkit-scrollbar-track { background: transparent; }
    .canvas-container.pdf-mode::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.2); border-radius: 3px; }
    .canvas-container.pdf-mode::-webkit-scrollbar-thumb:hover { background: rgba(0,0,0,0.3); }
    .canvas-container.pdf-mode::before { content: ''; flex: 1; min-height: 0; }
    .canvas-container.pdf-mode::after { content: ''; flex: 1; min-height: 0; }
    .pdf-page-container { position: relative; flex-shrink: 0; }
    #pdf-canvas { display: block; pointer-events: none; }
    #drawing-svg { position: absolute; top: 0; left: 0; display: block; overflow: visible; }
    .canvas-container:not(.pdf-mode) .pdf-page-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
    .canvas-container:not(.pdf-mode) #pdf-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
    .canvas-container:not(.pdf-mode) #drawing-svg { width: 100%; height: 100%; }
    .stroke-path { stroke: none; }
    .lasso-path { fill: none; stroke: var(--active); stroke-width: 2.5; stroke-dasharray: 6 4; }
    .selection-box { fill: none; stroke: var(--active); stroke-width: 2; stroke-dasharray: 5 3; }
    .selection-handle { fill: #fff; stroke: var(--active); stroke-width: 1.5; cursor: nwse-resize; }
    .rotation-handle { fill: #fff; stroke: var(--active); stroke-width: 1.5; cursor: grab; }
    .rotation-line { stroke: var(--active); stroke-width: 1.5; }
    .canvas-container.lasso-mode { cursor: crosshair; }
    .eraser-cursor { position: fixed; pointer-events: none; border: 1px solid #666; border-radius: 50%; transform: translate(-50%, -50%); z-index: 999; display: none; }
    .eraser-cursor.big-eraser { border-color: #ef4444; border-width: 1.5px; }
    .canvas-container.eraser-mode { cursor: none; }
    .canvas-container.eraser-mode .eraser-cursor { display: block; }

    /* PDF Controls in unified toolbar */
    .pdf-controls { display: none; align-items: center; gap: 4px; }
    .pdf-controls.visible { display: flex; }
    .pdf-nav-btn { width: 28px; height: 28px; border: none; background: var(--btn); border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s; }
    .pdf-nav-btn:hover:not(:disabled) { background: var(--btn-hover); }
    .pdf-nav-btn:disabled { opacity: 0.4; cursor: not-allowed; }
    .pdf-nav-btn svg { width: 14px; height: 14px; stroke: var(--text); stroke-width: 2; fill: none; }
    .pdf-page-info { font-size: 11px; font-weight: 500; color: var(--text); min-width: 50px; text-align: center; }
    .pdf-close-btn { background: #ef4444; }
    .pdf-close-btn:hover { background: #dc2626; }
    .pdf-close-btn svg { stroke: #fff; }

    /* Loading state */
    .loading-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 4000; opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; }
    .loading-overlay.visible { opacity: 1; visibility: visible; }
    .loading-spinner { width: 48px; height: 48px; border: 4px solid rgba(255,255,255,0.3); border-top-color: #fff; border-radius: 50%; animation: spin 0.8s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Graph paper background for no-PDF state */
    .canvas-container.no-pdf {
      background-color: var(--bg);
      background-image:
        linear-gradient(rgba(59, 130, 246, 0.2) 1px, transparent 1px),
        linear-gradient(90deg, rgba(59, 130, 246, 0.2) 1px, transparent 1px);
      background-size: 20px 20px;
    }

    #pdfInput { display: none; }

    /* PDF page transition animations */
    .pdf-page-container {
      transition: opacity 0.2s ease-out, transform 0.2s ease-out;
    }
    .pdf-page-container.slide-out-left {
      opacity: 0;
      transform: translateX(-30px);
    }
    .pdf-page-container.slide-out-right {
      opacity: 0;
      transform: translateX(30px);
    }
    .pdf-page-container.slide-in-left {
      opacity: 0;
      transform: translateX(30px);
    }
    .pdf-page-container.slide-in-right {
      opacity: 0;
      transform: translateX(-30px);
    }
  </style>
</head>
<body>
  <input type="file" id="pdfInput" accept="application/pdf">

  <!-- Invisible hover zone at top to trigger toolbar -->
  <div class="toolbar-hover-zone" id="toolbarHoverZone"></div>

  <div class="toolbar" id="toolbar">
    <button class="tool-btn" id="pdfBtn" title="Open PDF">
      <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>
    </button>
    <div class="divider"></div>
    <button class="tool-btn active" id="penTool" title="Pen (P)"><svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/><circle cx="11" cy="11" r="2"/></svg></button>
    <button class="tool-btn" id="eraserTool" title="Eraser (E)"><svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><path d="M20 20H7L3 16c-.8-.8-.8-2 0-2.8L13.5 3a2 2 0 012.8 0L21 7.5a2 2 0 010 2.8L11 20"/><path d="M6.5 13.5L11 9"/></svg></button>
    <button class="tool-btn" id="lassoTool" title="Lasso Select (L)"><svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2C6.5 2 2 6.5 2 12c0 3.5 1.8 6.5 4.5 8.3"/><path d="M12 2c5.5 0 10 4.5 10 10 0 2.5-.9 4.8-2.4 6.5"/><path d="M8.5 21.5c1.1.3 2.3.5 3.5.5"/><circle cx="12" cy="19" r="2"/><path d="M12 21v2"/></svg></button>
    <div class="divider"></div>
    <div class="stepper"><button class="stepper-btn" id="sizeDown">âˆ’</button><span class="stepper-value" id="sizeValue">5.5</span><button class="stepper-btn" id="sizeUp">+</button></div>
    <div class="divider"></div>
    <button class="tool-btn active" id="pressureBtn" title="Pressure Sensitivity"><svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83"/><circle cx="12" cy="12" r="3"/></svg></button>
    <div class="divider"></div>
    <button class="tool-btn" id="undoBtn" title="Undo (Ctrl+Z)"><svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><path d="M3 7v6h6"/><path d="M3 13a9 9 0 1 0 2.5-6.5L3 7"/></svg></button>
    <button class="tool-btn" id="redoBtn" title="Redo (Ctrl+Shift+Z)"><svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><path d="M21 7v6h-6"/><path d="M21 13a9 9 0 1 1-2.5-6.5L21 7"/></svg></button>
    <div class="divider"></div>
    <button class="tool-btn" id="clearBtn" title="Clear Page Annotations"><svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2"/><path d="M19 6l-1 14a2 2 0 01-2 2H8a2 2 0 01-2-2L5 6"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg></button>

    <!-- PDF Controls (shown when PDF is open) -->
    <div class="divider pdf-controls" id="pdfDivider"></div>
    <div class="pdf-controls" id="pdfControls">
      <button class="pdf-nav-btn" id="prevPage" title="Previous Page">
        <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"/></svg>
      </button>
      <span class="pdf-page-info" id="pageInfo">1 / 1</span>
      <button class="pdf-nav-btn" id="nextPage" title="Next Page">
        <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"/></svg>
      </button>
      <button class="pdf-nav-btn pdf-close-btn" id="closePdf" title="Close PDF">
        <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
      </button>
    </div>
  </div>

  <div class="color-modal-overlay" id="colorModalOverlay">
    <div class="color-modal">
      <div class="color-modal-title">Choose Color</div>
      <div class="color-modal-grid" id="colorModalGrid"></div>
    </div>
  </div>

  <div class="loading-overlay" id="loadingOverlay">
    <div class="loading-spinner"></div>
  </div>

  <div class="canvas-container no-pdf" id="canvasContainer">
    <div class="pdf-page-container" id="pdfPageContainer">
      <canvas id="pdf-canvas"></canvas>
      <svg id="drawing-svg" xmlns="http://www.w3.org/2000/svg"><g id="strokes-group"></g></svg>
    </div>
    <div class="eraser-cursor" id="eraserCursor"></div>
  </div>

  <script type="module">
    // Initialize PDF.js
    const pdfjsLib = await import('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.min.mjs');
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.worker.min.mjs';

    const dpr = window.devicePixelRatio || 1;
    const SEGMENT_MAX = 1200, BIG_ERASER_MULT = 6, TAP_THRESHOLD = 500;
    const sizes = Array.from({length: 63}, (_, i) => (i + 1) * 0.5);
    const colors = ['#1f2937','#6b7280','#ef4444','#f97316','#eab308','#22c55e','#14b8a6','#3b82f6','#8b5cf6','#ec4899'];

    let tool = 'pen', width = 5.5, color = '#1f2937', sizeIdx = 10, drawing = false, path = null, points = [];
    let strokes = [], undoStack = [];
    let eraserEnd = false, lassoEnd = false, prevTool = 'pen', pressure = true, bigEraser = false, tapTimes = [], segLen = 0;

    // PDF state
    let pdfDoc = null, currentPage = 1, totalPages = 0;
    let pageAnnotations = {}; // Store annotations per page: { pageNum: { strokes: [], undoStack: [] } }

    // PDF coordinate system - used for fixed coordinate mapping
    let pdfPageWidth = 0, pdfPageHeight = 0;  // Native PDF page dimensions

    // Get effective stroke width (scaled for PDF mode)
    const getEffectiveWidth = () => {
      if (pdfDoc && pdfPageWidth > 0) {
        const containerWidth = container.getBoundingClientRect().width;
        const scale = pdfPageWidth / (containerWidth * dpr);
        return width * scale;
      }
      return width;
    };

    // Toolbar visibility state
    let toolbarVisible = true;
    let hideToolbarTimeout = null;

    // Lasso state
    let lassoPath = null;
    let lassoPoints = [];
    let selectedStrokes = [];
    let selectionBoxes = [];
    let selectionHandles = [];
    let rotationHandle = null;
    let rotationLine = null;
    let isDraggingSelection = false;
    let isScalingSelection = false;
    let isRotatingSelection = false;
    let activeHandle = null; // 'tl', 'tr', 'bl', 'br' for corners
    let dragStartX = 0, dragStartY = 0;
    let selectionBounds = null;
    let originalBounds = null;
    let originalStrokePoints = [];
    let rotationCenterX = 0, rotationCenterY = 0;
    let startAngle = 0;
    let currentRotation = 0;
    let previousRotation = 0; // Accumulated rotation from previous operations
    let scaleAnchorWorldX = 0, scaleAnchorWorldY = 0; // World-space anchor for scaling

    const $ = id => document.getElementById(id);
    const svg = $('drawing-svg'), group = $('strokes-group'), container = $('canvasContainer');
    const cursor = $('eraserCursor'), sizeVal = $('sizeValue');
    const modal = $('colorModalOverlay'), grid = $('colorModalGrid');
    const pdfCanvas = $('pdf-canvas'), pdfCtx = pdfCanvas.getContext('2d');
    const loadingOverlay = $('loadingOverlay');
    const toolbar = $('toolbar'), pageInfo = $('pageInfo');
    const pdfInput = $('pdfInput');
    const pdfControls = $('pdfControls'), pdfDivider = $('pdfDivider');
    const toolbarHoverZone = $('toolbarHoverZone');

    // Show/hide toolbar functions
    const showToolbar = () => {
      toolbarVisible = true;
      toolbar.classList.remove('hidden');
      clearTimeout(hideToolbarTimeout);
    };

    const hideToolbar = () => {
      hideToolbarTimeout = setTimeout(() => {
        toolbarVisible = false;
        toolbar.classList.add('hidden');
      }, 300);
    };

    const cancelHide = () => {
      clearTimeout(hideToolbarTimeout);
    };

    // Initialize color palette
    colors.forEach(c => {
      const b = document.createElement('button');
      b.className = 'color-modal-btn' + (c === color ? ' selected' : '');
      b.style.background = c;
      b.dataset.color = c;
      b.onclick = () => {
        color = c;
        sizeVal.style.color = c;
        grid.querySelectorAll('.color-modal-btn').forEach(x => x.classList.toggle('selected', x.dataset.color === c));
        modal.classList.remove('visible');
      };
      grid.appendChild(b);
    });

    sizeVal.onclick = () => modal.classList.add('visible');
    modal.onclick = e => { if (e.target === modal) modal.classList.remove('visible'); };

    const setTool = (t, preserveSelection = false) => {
      tool = t;
      $('penTool').classList.toggle('active', t === 'pen');
      $('eraserTool').classList.toggle('active', t === 'eraser');
      $('lassoTool').classList.toggle('active', t === 'lasso');
      container.classList.toggle('eraser-mode', t === 'eraser');
      container.classList.toggle('lasso-mode', t === 'lasso');
      if (t !== 'lasso' && !preserveSelection) clearSelection();
      updateCursor();
    };

    const updateCursor = () => {
      // Cursor size in CSS pixels - diameter = width * 3 screen pixels
      const s = width * 3 * (bigEraser ? BIG_ERASER_MULT : 1);
      cursor.style.width = cursor.style.height = s + 'px';
      cursor.classList.toggle('big-eraser', bigEraser);
    };

    const checkTap = () => {
      const n = Date.now();
      tapTimes.push(n);
      tapTimes = tapTimes.filter(t => n - t < TAP_THRESHOLD);
      if (tapTimes.length >= 3) { bigEraser = true; tapTimes = []; updateCursor(); }
    };

    const resetBig = () => { if (bigEraser) { bigEraser = false; tapTimes = []; updateCursor(); } };

    // Lasso functions
    const clearSelection = () => {
      selectedStrokes = [];
      selectionBoxes.forEach(box => box.remove());
      selectionBoxes = [];
      selectionHandles.forEach(h => h.remove());
      selectionHandles = [];
      if (rotationHandle) { rotationHandle.remove(); rotationHandle = null; }
      if (rotationLine) { rotationLine.remove(); rotationLine = null; }
      if (lassoPath) { lassoPath.remove(); lassoPath = null; }
      lassoPoints = [];
      selectionBounds = null;
      originalBounds = null;
      originalStrokePoints = [];
      currentRotation = 0;
      previousRotation = 0;
    };

    const pointInPolygon = (x, y, polygon) => {
      let inside = false;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i].x, yi = polygon[i].y;
        const xj = polygon[j].x, yj = polygon[j].y;
        if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
          inside = !inside;
        }
      }
      return inside;
    };

    const createSelectionHandles = () => {
      selectionHandles.forEach(h => h.remove());
      selectionHandles = [];
      if (rotationHandle) { rotationHandle.remove(); rotationHandle = null; }
      if (rotationLine) { rotationLine.remove(); rotationLine = null; }
      if (!selectionBounds) return;

      const handleSize = 40;
      const rotationOffset = 50;
      const corners = [
        { id: 'tl', x: selectionBounds.x, y: selectionBounds.y },
        { id: 'tr', x: selectionBounds.x + selectionBounds.width, y: selectionBounds.y },
        { id: 'bl', x: selectionBounds.x, y: selectionBounds.y + selectionBounds.height },
        { id: 'br', x: selectionBounds.x + selectionBounds.width, y: selectionBounds.y + selectionBounds.height }
      ];

      corners.forEach(corner => {
        const handle = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        handle.classList.add('selection-handle');
        handle.setAttribute('x', corner.x - handleSize / 2);
        handle.setAttribute('y', corner.y - handleSize / 2);
        handle.setAttribute('width', handleSize);
        handle.setAttribute('height', handleSize);
        handle.setAttribute('data-handle', corner.id);
        group.appendChild(handle);
        selectionHandles.push(handle);
      });

      // Create rotation line
      const centerX = selectionBounds.x + selectionBounds.width / 2;
      const topY = selectionBounds.y;
      rotationLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      rotationLine.classList.add('rotation-line');
      rotationLine.setAttribute('x1', centerX);
      rotationLine.setAttribute('y1', topY);
      rotationLine.setAttribute('x2', centerX);
      rotationLine.setAttribute('y2', topY - rotationOffset);
      group.appendChild(rotationLine);

      // Create rotation handle (circle at top center)
      rotationHandle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      rotationHandle.classList.add('rotation-handle');
      rotationHandle.setAttribute('cx', centerX);
      rotationHandle.setAttribute('cy', topY - rotationOffset);
      rotationHandle.setAttribute('r', 20);
      group.appendChild(rotationHandle);
    };

    const updateSelectionUI = (preserveRotation = false) => {
      if (!selectionBounds || selectionBoxes.length === 0) return;

      // Update selection box
      selectionBoxes[0].setAttribute('x', selectionBounds.x);
      selectionBoxes[0].setAttribute('y', selectionBounds.y);
      selectionBoxes[0].setAttribute('width', selectionBounds.width);
      selectionBoxes[0].setAttribute('height', selectionBounds.height);

      // Update handles
      const handleSize = 40;
      const rotationOffset = 50;
      const corners = [
        { id: 'tl', x: selectionBounds.x, y: selectionBounds.y },
        { id: 'tr', x: selectionBounds.x + selectionBounds.width, y: selectionBounds.y },
        { id: 'bl', x: selectionBounds.x, y: selectionBounds.y + selectionBounds.height },
        { id: 'br', x: selectionBounds.x + selectionBounds.width, y: selectionBounds.y + selectionBounds.height }
      ];

      selectionHandles.forEach((handle, i) => {
        handle.setAttribute('x', corners[i].x - handleSize / 2);
        handle.setAttribute('y', corners[i].y - handleSize / 2);
      });

      // Update rotation handle and line
      if (rotationHandle && rotationLine) {
        const centerX = selectionBounds.x + selectionBounds.width / 2;
        const topY = selectionBounds.y;
        rotationLine.setAttribute('x1', centerX);
        rotationLine.setAttribute('y1', topY);
        rotationLine.setAttribute('x2', centerX);
        rotationLine.setAttribute('y2', topY - rotationOffset);
        rotationHandle.setAttribute('cx', centerX);
        rotationHandle.setAttribute('cy', topY - rotationOffset);
      }

      // Preserve rotation transform if needed
      if (preserveRotation && currentRotation !== 0) {
        const cx = selectionBounds.x + selectionBounds.width / 2;
        const cy = selectionBounds.y + selectionBounds.height / 2;
        const degrees = currentRotation * (180 / Math.PI);
        const rotateTransform = `rotate(${degrees}, ${cx}, ${cy})`;

        if (selectionBoxes[0]) {
          selectionBoxes[0].setAttribute('transform', rotateTransform);
        }
        selectionHandles.forEach(handle => {
          handle.setAttribute('transform', rotateTransform);
        });
        if (rotationHandle) {
          rotationHandle.setAttribute('transform', rotateTransform);
        }
        if (rotationLine) {
          rotationLine.setAttribute('transform', rotateTransform);
        }
      }
    };

    const selectStrokesInLasso = () => {
      // Clear previous selection boxes (but not the lasso path)
      selectionBoxes.forEach(box => box.remove());
      selectionBoxes = [];
      selectionHandles.forEach(h => h.remove());
      selectionHandles = [];
      selectedStrokes = [];
      if (lassoPoints.length < 3) return;

      // Find all strokes inside the lasso
      strokes.forEach(s => {
        const isInside = s.points.some(p => pointInPolygon(p.x, p.y, lassoPoints));
        if (isInside) {
          selectedStrokes.push(s);
        }
      });

      // Create a bounding box based on the lasso selection area
      if (selectedStrokes.length > 0) {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        lassoPoints.forEach(p => {
          minX = Math.min(minX, p.x);
          minY = Math.min(minY, p.y);
          maxX = Math.max(maxX, p.x);
          maxY = Math.max(maxY, p.y);
        });
        selectionBounds = { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.classList.add('selection-box');
        rect.setAttribute('x', minX);
        rect.setAttribute('y', minY);
        rect.setAttribute('width', maxX - minX);
        rect.setAttribute('height', maxY - minY);
        rect.setAttribute('rx', 3);
        group.appendChild(rect);
        selectionBoxes.push(rect);

        // Add corner handles
        createSelectionHandles();
      } else {
        selectionBounds = null;
      }
    };

    const deleteSelectedStrokes = () => {
      if (selectedStrokes.length === 0) return;
      selectedStrokes.forEach(s => {
        s.element.remove();
        const idx = strokes.indexOf(s);
        if (idx > -1) {
          undoStack.push(strokes.splice(idx, 1)[0]);
        }
      });
      selectedStrokes = [];
      selectionBoxes.forEach(box => box.remove());
      selectionBoxes = [];
      selectionHandles.forEach(h => h.remove());
      selectionHandles = [];
      if (rotationHandle) { rotationHandle.remove(); rotationHandle = null; }
      if (rotationLine) { rotationLine.remove(); rotationLine = null; }
      selectionBounds = null;
      currentRotation = 0;
      previousRotation = 0;
      savePageAnnotations();
    };

    // Transform point by inverse rotation to check against unrotated bounds
    const transformPointForHitTest = (x, y) => {
      if (currentRotation === 0) return { x, y };
      const cx = selectionBounds.x + selectionBounds.width / 2;
      const cy = selectionBounds.y + selectionBounds.height / 2;
      const cos = Math.cos(-currentRotation);
      const sin = Math.sin(-currentRotation);
      const dx = x - cx;
      const dy = y - cy;
      return {
        x: cx + dx * cos - dy * sin,
        y: cy + dx * sin + dy * cos
      };
    };

    const isInsideSelectionBox = (x, y) => {
      if (!selectionBounds || selectedStrokes.length === 0) return false;
      const p = transformPointForHitTest(x, y);
      return p.x >= selectionBounds.x && p.x <= selectionBounds.x + selectionBounds.width &&
             p.y >= selectionBounds.y && p.y <= selectionBounds.y + selectionBounds.height;
    };

    const getHandleAtPoint = (x, y) => {
      if (!selectionBounds || selectedStrokes.length === 0) return null;
      const p = transformPointForHitTest(x, y);
      const handleSize = 25; // Slightly larger hit area for 40px handles
      const corners = [
        { id: 'tl', x: selectionBounds.x, y: selectionBounds.y },
        { id: 'tr', x: selectionBounds.x + selectionBounds.width, y: selectionBounds.y },
        { id: 'bl', x: selectionBounds.x, y: selectionBounds.y + selectionBounds.height },
        { id: 'br', x: selectionBounds.x + selectionBounds.width, y: selectionBounds.y + selectionBounds.height }
      ];
      for (const corner of corners) {
        if (Math.abs(p.x - corner.x) <= handleSize && Math.abs(p.y - corner.y) <= handleSize) {
          return corner.id;
        }
      }
      return null;
    };

    const moveSelection = (dx, dy) => {
      // Move all selected strokes
      selectedStrokes.forEach(s => {
        s.points = s.points.map(p => ({ ...p, x: p.x + dx, y: p.y + dy }));
        s.element.setAttribute('d', buildPath(s.points, s.width));
      });
      // Update selection bounds and box
      if (selectionBounds) {
        selectionBounds.x += dx;
        selectionBounds.y += dy;
        updateSelectionUI(true); // preserve rotation
      }
    };

    const scaleSelection = (newX, newY) => {
      if (!originalBounds || !activeHandle) return;

      const anchorX = scaleAnchorWorldX;
      const anchorY = scaleAnchorWorldY;
      const origCx = originalBounds.x + originalBounds.width / 2;
      const origCy = originalBounds.y + originalBounds.height / 2;
      const cos = Math.cos(currentRotation);
      const sin = Math.sin(currentRotation);

      // Get the original handle position in world space
      let handleLocalX, handleLocalY;
      if (activeHandle === 'tl') {
        handleLocalX = originalBounds.x;
        handleLocalY = originalBounds.y;
      } else if (activeHandle === 'tr') {
        handleLocalX = originalBounds.x + originalBounds.width;
        handleLocalY = originalBounds.y;
      } else if (activeHandle === 'bl') {
        handleLocalX = originalBounds.x;
        handleLocalY = originalBounds.y + originalBounds.height;
      } else {
        handleLocalX = originalBounds.x + originalBounds.width;
        handleLocalY = originalBounds.y + originalBounds.height;
      }

      const dxH = handleLocalX - origCx;
      const dyH = handleLocalY - origCy;
      const handleWorldX = origCx + dxH * cos - dyH * sin;
      const handleWorldY = origCy + dxH * sin + dyH * cos;

      const origDist = Math.hypot(handleWorldX - anchorX, handleWorldY - anchorY);
      const newDist = Math.hypot(newX - anchorX, newY - anchorY);

      // Calculate uniform scale with minimum
      const minScale = 20 / Math.max(originalBounds.width, originalBounds.height);
      const scale = Math.max(minScale, origDist > 0 ? newDist / origDist : 1);

      // Scale all strokes from the world-space anchor
      selectedStrokes.forEach((s, i) => {
        const origPoints = originalStrokePoints[i];
        s.points = origPoints.map(pt => ({
          ...pt,
          x: anchorX + (pt.x - anchorX) * scale,
          y: anchorY + (pt.y - anchorY) * scale
        }));
        s.element.setAttribute('d', buildPath(s.points, s.width));
      });

      // Calculate new bounds
      const scaledWidth = originalBounds.width * scale;
      const scaledHeight = originalBounds.height * scale;
      const newCx = anchorX + (origCx - anchorX) * scale;
      const newCy = anchorY + (origCy - anchorY) * scale;

      selectionBounds.x = newCx - scaledWidth / 2;
      selectionBounds.y = newCy - scaledHeight / 2;
      selectionBounds.width = scaledWidth;
      selectionBounds.height = scaledHeight;

      updateSelectionUI(true);
    };

    const isOnRotationHandle = (x, y) => {
      if (!selectionBounds || selectedStrokes.length === 0 || !rotationHandle) return false;
      const p = transformPointForHitTest(x, y);
      const rotationOffset = 50;
      const centerX = selectionBounds.x + selectionBounds.width / 2;
      const handleY = selectionBounds.y - rotationOffset;
      const hitRadius = 25;
      return Math.hypot(p.x - centerX, p.y - handleY) <= hitRadius;
    };

    const rotateSelection = (x, y) => {
      if (!originalBounds) return;

      const angle = Math.atan2(y - rotationCenterY, x - rotationCenterX);
      const deltaAngle = angle - startAngle;
      const totalRotation = previousRotation + deltaAngle;
      const cos = Math.cos(deltaAngle);
      const sin = Math.sin(deltaAngle);

      // Rotate all strokes around the center
      selectedStrokes.forEach((s, i) => {
        const origPoints = originalStrokePoints[i];
        s.points = origPoints.map(p => {
          const dx = p.x - rotationCenterX;
          const dy = p.y - rotationCenterY;
          return { ...p, x: rotationCenterX + dx * cos - dy * sin, y: rotationCenterY + dx * sin + dy * cos };
        });
        s.element.setAttribute('d', buildPath(s.points, s.width));
      });

      // Apply rotation transform to selection UI
      const rotateTransform = `rotate(${totalRotation * (180 / Math.PI)}, ${rotationCenterX}, ${rotationCenterY})`;
      if (selectionBoxes[0]) selectionBoxes[0].setAttribute('transform', rotateTransform);
      selectionHandles.forEach(h => h.setAttribute('transform', rotateTransform));
      if (rotationHandle) rotationHandle.setAttribute('transform', rotateTransform);
      if (rotationLine) rotationLine.setAttribute('transform', rotateTransform);

      currentRotation = totalRotation;
    };

    // Save current page annotations
    const savePageAnnotations = () => {
      if (pdfDoc) {
        pageAnnotations[currentPage] = {
          strokes: strokes.map(s => ({ ...s })),
          undoStack: undoStack.map(s => ({ ...s }))
        };
      }
    };

    // Load page annotations
    const loadPageAnnotations = () => {
      group.innerHTML = '';
      const data = pageAnnotations[currentPage];
      if (data) {
        strokes = data.strokes.map(s => {
          const el = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          el.classList.add('stroke-path');
          el.setAttribute('fill', s.color);
          el.setAttribute('d', buildPath(s.points, s.width));
          group.appendChild(el);
          return { ...s, element: el };
        });
        undoStack = data.undoStack.map(s => {
          const el = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          el.classList.add('stroke-path');
          el.setAttribute('fill', s.color);
          el.setAttribute('d', buildPath(s.points, s.width));
          return { ...s, element: el };
        });
      } else {
        strokes = [];
        undoStack = [];
      }
    };

    const undo = () => {
      if (strokes.length) {
        const s = strokes.pop();
        undoStack.push(s);
        s.element.remove();
        savePageAnnotations();
      }
    };

    const redo = () => {
      if (undoStack.length) {
        const s = undoStack.pop();
        group.appendChild(s.element);
        strokes.push(s);
        savePageAnnotations();
      }
    };

    const isPen = e => e.pointerType === 'pen';
    const isEraser = e => e.button === 5 || (e.buttons & 32) !== 0;
    const isLassoButton = e => e.button === 2 || (e.buttons & 2) !== 0;

    // Convert screen coordinates to SVG/PDF-space coordinates
    const getData = e => {
      const r = svg.getBoundingClientRect();

      if (pdfDoc && pdfPageWidth > 0) {
        // When PDF is loaded, SVG is sized to match PDF page
        // Convert screen coords to PDF page coords using the viewBox
        const x = ((e.clientX - r.left) / r.width) * pdfPageWidth;
        const y = ((e.clientY - r.top) / r.height) * pdfPageHeight;
        return { x, y, pressure: e.pressure ?? 0.5 };
      } else {
        // No PDF loaded, use screen coordinates with dpr
        return { x: (e.clientX - r.left) * dpr, y: (e.clientY - r.top) * dpr, pressure: e.pressure ?? 0.5 };
      }
    };

    function buildPath(pts, w) {
      if (pts.length < 2) {
        const p = pts[0], r = (w * p.pressure * 1.5) / 2;
        return `M${p.x-r},${p.y}a${r},${r} 0 1,0 ${r*2},0a${r},${r} 0 1,0 ${-r*2},0`;
      }
      const L = [], R = [];
      for (let i = 0; i < pts.length; i++) {
        const p = pts[i], pr = pressure ? Math.max(0.25, Math.pow(p.pressure, 0.75)) : 0.7, hw = (w * pr * 1.5) / 2;
        let dx, dy;
        if (i === 0) { dx = pts[1].x - p.x; dy = pts[1].y - p.y; }
        else if (i === pts.length - 1) { dx = p.x - pts[i-1].x; dy = p.y - pts[i-1].y; }
        else { dx = pts[i+1].x - pts[i-1].x; dy = pts[i+1].y - pts[i-1].y; }
        const len = Math.sqrt(dx*dx + dy*dy) || 1, nx = -dy/len, ny = dx/len;
        L.push({ x: p.x + nx*hw, y: p.y + ny*hw });
        R.push({ x: p.x - nx*hw, y: p.y - ny*hw });
      }
      let d = `M${L[0].x},${L[0].y}`;
      for (let i = 1; i < L.length; i++) d += `Q${L[i-1].x},${L[i-1].y},${(L[i-1].x+L[i].x)/2},${(L[i-1].y+L[i].y)/2}`;
      const ll = L[L.length-1], lr = R[R.length-1];
      d += `L${(ll.x+lr.x)/2},${(ll.y+lr.y)/2}`;
      for (let i = R.length-2; i >= 0; i--) d += `Q${R[i+1].x},${R[i+1].y},${(R[i+1].x+R[i].x)/2},${(R[i+1].y+R[i].y)/2}`;
      d += `Q${R[0].x},${R[0].y},${L[0].x},${L[0].y}Z`;
      return d;
    }

    const newPath = () => {
      path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.classList.add('stroke-path');
      path.setAttribute('fill', color);
      path.setAttribute('d', buildPath(points, getEffectiveWidth()));
      group.appendChild(path);
    };

    const finalize = () => {
      if (path && points.length > 1) {
        strokes.push({ element: path, points: [...points], color, width: getEffectiveWidth() });
        savePageAnnotations();
      }
    };

    const setCursor = e => {
      cursor.style.left = e.clientX + 'px';
      cursor.style.top = e.clientY + 'px';
    };

    function start(e) {
      if (!isPen(e)) return;
      if (isEraser(e)) {
        eraserEnd = true;
        lassoEnd = false;
        prevTool = tool;
        if (tool !== 'eraser') setTool('eraser');
        checkTap();
        setCursor(e);
      } else if (isLassoButton(e)) {
        lassoEnd = true;
        eraserEnd = false;
        prevTool = tool;
        if (tool !== 'lasso') setTool('lasso');
      } else {
        if (e.button && e.button !== 0) return;
        eraserEnd = false;
        lassoEnd = false;
      }
      e.preventDefault();
      const d = getData(e);

      // Check if clicking on rotation handle
      if (tool === 'lasso' && isOnRotationHandle(d.x, d.y)) {
        isRotatingSelection = true;
        originalBounds = { ...selectionBounds };
        originalStrokePoints = selectedStrokes.map(s => s.points.map(p => ({ ...p })));
        rotationCenterX = selectionBounds.x + selectionBounds.width / 2;
        rotationCenterY = selectionBounds.y + selectionBounds.height / 2;
        startAngle = Math.atan2(d.y - rotationCenterY, d.x - rotationCenterX);
        previousRotation = currentRotation; // Store accumulated rotation
        drawing = false;
        return;
      }

      // Check if clicking on a handle to scale
      if (tool === 'lasso') {
        const handle = getHandleAtPoint(d.x, d.y);
        if (handle) {
          isScalingSelection = true;
          activeHandle = handle;
          originalBounds = { ...selectionBounds };
          originalStrokePoints = selectedStrokes.map(s => s.points.map(p => ({ ...p })));

          // Calculate world-space anchor (opposite corner) at the start of scaling
          const cx = selectionBounds.x + selectionBounds.width / 2;
          const cy = selectionBounds.y + selectionBounds.height / 2;
          let anchorLocalX, anchorLocalY;
          if (handle === 'tl') {
            anchorLocalX = selectionBounds.x + selectionBounds.width;
            anchorLocalY = selectionBounds.y + selectionBounds.height;
          } else if (handle === 'tr') {
            anchorLocalX = selectionBounds.x;
            anchorLocalY = selectionBounds.y + selectionBounds.height;
          } else if (handle === 'bl') {
            anchorLocalX = selectionBounds.x + selectionBounds.width;
            anchorLocalY = selectionBounds.y;
          } else { // br
            anchorLocalX = selectionBounds.x;
            anchorLocalY = selectionBounds.y;
          }
          // Transform anchor to world space
          const cos = Math.cos(currentRotation);
          const sin = Math.sin(currentRotation);
          const dxA = anchorLocalX - cx;
          const dyA = anchorLocalY - cy;
          scaleAnchorWorldX = cx + dxA * cos - dyA * sin;
          scaleAnchorWorldY = cy + dxA * sin + dyA * cos;

          drawing = false;
          return;
        }
      }

      // Check if clicking inside selection box to drag
      if (tool === 'lasso' && isInsideSelectionBox(d.x, d.y)) {
        isDraggingSelection = true;
        dragStartX = d.x;
        dragStartY = d.y;
        drawing = false;
        return;
      }

      drawing = true;
      points = [];
      segLen = 0;
      undoStack = [];
      points.push(d);
      if (tool === 'pen') newPath();
      if (tool === 'eraser') setCursor(e);
      if (tool === 'lasso') {
        // If there was a selection and user clicked outside, switch to pen tool
        if (selectedStrokes.length > 0) {
          clearSelection();
          setTool('pen');
          drawing = false;
          return;
        }
        clearSelection();
        lassoPoints = [{ x: d.x, y: d.y }];
        lassoPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        lassoPath.classList.add('lasso-path');
        lassoPath.setAttribute('d', `M${d.x},${d.y}`);
        group.appendChild(lassoPath);
      }
    }

    function move(e) {
      if (!isPen(e)) return;

      // Handle rotation
      if (isRotatingSelection) {
        e.preventDefault();
        const d = getData(e);
        rotateSelection(d.x, d.y);
        return;
      }

      // Handle scaling selection
      if (isScalingSelection) {
        e.preventDefault();
        const d = getData(e);
        scaleSelection(d.x, d.y);
        return;
      }

      // Handle dragging selection
      if (isDraggingSelection) {
        e.preventDefault();
        const d = getData(e);
        const dx = d.x - dragStartX;
        const dy = d.y - dragStartY;
        moveSelection(dx, dy);
        dragStartX = d.x;
        dragStartY = d.y;
        return;
      }

      if (!drawing) return;
      e.preventDefault();
      const d = getData(e);
      if (tool === 'eraser') { setCursor(e); erase(d.x, d.y); return; }
      if (tool === 'lasso') {
        const last = lassoPoints[lassoPoints.length - 1];
        const dist = Math.hypot(d.x - last.x, d.y - last.y);
        if (dist < 3) return;
        lassoPoints.push({ x: d.x, y: d.y });
        let pathD = `M${lassoPoints[0].x},${lassoPoints[0].y}`;
        for (let i = 1; i < lassoPoints.length; i++) {
          pathD += `L${lassoPoints[i].x},${lassoPoints[i].y}`;
        }
        lassoPath.setAttribute('d', pathD);
        return;
      }
      const last = points[points.length - 1], dist = Math.hypot(d.x - last.x, d.y - last.y);
      if (dist < 2) return;
      segLen += dist;
      points.push(d);
      path.setAttribute('d', buildPath(points, getEffectiveWidth()));
      if (segLen >= SEGMENT_MAX) {
        finalize();
        points = points.slice(-2);
        segLen = 0;
        newPath();
      }
    }

    function stop(e) {
      if (e && !isPen(e)) return;

      // Handle end of rotation
      if (isRotatingSelection) {
        isRotatingSelection = false;
        // Keep the transform on UI elements - don't recalculate bounds
        // The selection box stays rotated with the strokes
        originalBounds = null;
        originalStrokePoints = [];
        savePageAnnotations();
        return;
      }

      // Handle end of scaling selection
      if (isScalingSelection) {
        isScalingSelection = false;
        activeHandle = null;
        originalBounds = null;
        originalStrokePoints = [];
        savePageAnnotations();
        return;
      }

      // Handle end of dragging selection
      if (isDraggingSelection) {
        isDraggingSelection = false;
        savePageAnnotations();
        return;
      }

      if (!drawing) return;
      drawing = false;
      if (tool === 'pen' && path) {
        strokes.push({ element: path, points: [...points], color, width: getEffectiveWidth() });
        savePageAnnotations();
        path = null;
      }
      if (tool === 'lasso' && lassoPath && lassoPoints.length >= 3) {
        // Remove lasso path first, then show selection box
        lassoPath.remove();
        lassoPath = null;
        selectStrokesInLasso();
      } else if (tool === 'lasso') {
        clearSelection();
      }
      points = [];
      if (eraserEnd) {
        eraserEnd = false;
        resetBig();
        if (prevTool !== 'eraser') setTool(prevTool);
      }
      if (lassoEnd) {
        lassoEnd = false;
        // If strokes were selected, keep lasso tool active for manipulation
        // Otherwise switch back to previous tool
        if (selectedStrokes.length === 0 && prevTool !== 'lasso') {
          setTool(prevTool);
        }
        // If strokes are selected, stay in lasso mode to allow rotate/move/scale
      }
    }

    function erase(x, y) {
      // Eraser radius: multiply by dpr to get consistent screen-pixel size in both modes
      const r = getEffectiveWidth() * 1.5 * (bigEraser ? BIG_ERASER_MULT : 1) * dpr;
      let erased = false;
      for (let i = strokes.length - 1; i >= 0; i--) {
        const s = strokes[i], b = s.element.getBBox();
        if (x < b.x-r || x > b.x+b.width+r || y < b.y-r || y > b.y+b.height+r) continue;
        for (const p of s.points) {
          if (Math.hypot(x-p.x, y-p.y) < r + s.width) {
            s.element.remove();
            undoStack.push(strokes.splice(i,1)[0]);
            erased = true;
            break;
          }
        }
      }
      if (erased) savePageAnnotations();
    }

    // PDF rendering
    async function renderPage(pageNum) {
      if (!pdfDoc) return;

      const page = await pdfDoc.getPage(pageNum);
      const containerRect = container.getBoundingClientRect();
      const horizontalMargin = 60; // 30px left + 30px right

      // Get native PDF page dimensions
      const viewport = page.getViewport({ scale: 1 });
      pdfPageWidth = viewport.width;
      pdfPageHeight = viewport.height;

      // Calculate scale to fit WIDTH with margins
      const availableWidth = containerRect.width - horizontalMargin;
      const pdfScale = (availableWidth * dpr) / viewport.width;

      const scaledViewport = page.getViewport({ scale: pdfScale });

      // Set canvas size to fit the scaled page exactly
      const displayWidth = availableWidth;
      const displayHeight = scaledViewport.height / dpr;

      pdfCanvas.width = scaledViewport.width;
      pdfCanvas.height = scaledViewport.height;
      pdfCanvas.style.width = displayWidth + 'px';
      pdfCanvas.style.height = displayHeight + 'px';

      // Set the page container size
      const pageContainer = $('pdfPageContainer');
      pageContainer.style.width = displayWidth + 'px';
      pageContainer.style.height = displayHeight + 'px';

      // Clear and render (no offset needed - page fills width)
      pdfCtx.fillStyle = '#fff';
      pdfCtx.fillRect(0, 0, pdfCanvas.width, pdfCanvas.height);

      await page.render({
        canvasContext: pdfCtx,
        viewport: scaledViewport
      }).promise;

      // Set SVG viewBox to PDF page dimensions so strokes align with PDF content
      svg.setAttribute('viewBox', `0 0 ${pdfPageWidth} ${pdfPageHeight}`);

      // SVG fills the page container
      svg.style.width = '100%';
      svg.style.height = '100%';

      // Update page info
      pageInfo.textContent = `${pageNum} / ${totalPages}`;
      $('prevPage').disabled = pageNum <= 1;
      $('nextPage').disabled = pageNum >= totalPages;
    }

    async function loadPDF(file) {
      loadingOverlay.classList.add('visible');

      try {
        const arrayBuffer = await file.arrayBuffer();
        pdfDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        totalPages = pdfDoc.numPages;
        currentPage = 1;
        pageAnnotations = {};

        // Clear current drawings
        group.innerHTML = '';
        strokes = [];
        undoStack = [];

        container.classList.remove('no-pdf');
        container.classList.add('pdf-mode');

        // Show PDF controls in toolbar
        pdfControls.classList.add('visible');
        pdfDivider.classList.add('visible');

        await renderPage(1);
        loadPageAnnotations();
      } catch (err) {
        console.error('Error loading PDF:', err);
      } finally {
        loadingOverlay.classList.remove('visible');
      }
    }

    function closePDF() {
      pdfDoc = null;
      currentPage = 1;
      totalPages = 0;
      pageAnnotations = {};
      pdfPageWidth = 0;
      pdfPageHeight = 0;

      pdfCtx.clearRect(0, 0, pdfCanvas.width, pdfCanvas.height);
      group.innerHTML = '';
      strokes = [];
      undoStack = [];

      // Reset page container and SVG to full container size
      const pageContainer = $('pdfPageContainer');
      pageContainer.style.width = '';
      pageContainer.style.height = '';
      svg.style.width = '100%';
      svg.style.height = '100%';
      const r = container.getBoundingClientRect();
      svg.setAttribute('viewBox', `0 0 ${r.width * dpr} ${r.height * dpr}`);

      container.classList.remove('pdf-mode');
      container.classList.add('no-pdf');

      // Hide PDF controls in toolbar
      pdfControls.classList.remove('visible');
      pdfDivider.classList.remove('visible');
    }

    async function goToPage(pageNum) {
      if (!pdfDoc || pageNum < 1 || pageNum > totalPages) return;

      const pageContainer = $('pdfPageContainer');
      const direction = pageNum > currentPage ? 'left' : 'right';

      // Slide out animation
      pageContainer.classList.add(`slide-out-${direction}`);

      await new Promise(resolve => setTimeout(resolve, 200));

      savePageAnnotations();
      currentPage = pageNum;
      await renderPage(pageNum);
      loadPageAnnotations();
      container.scrollTop = 0;

      // Prepare slide in from opposite direction
      pageContainer.classList.remove(`slide-out-${direction}`);
      pageContainer.classList.add(`slide-in-${direction}`);

      // Force reflow to ensure the slide-in class is applied before removing it
      void pageContainer.offsetWidth;

      // Slide in animation
      pageContainer.classList.remove(`slide-in-${direction}`);
    }

    const resize = () => {
      const r = container.getBoundingClientRect();
      if (pdfDoc) {
        // Re-render PDF page - this will also update SVG positioning
        renderPage(currentPage);
      } else {
        // No PDF - SVG fills container
        svg.setAttribute('viewBox', `0 0 ${r.width * dpr} ${r.height * dpr}`);
      }
    };

    // Event listeners for toolbar hover zone (stylus only)
    toolbarHoverZone.addEventListener('pointerenter', e => {
      if (e.pointerType === 'pen') {
        showToolbar();
      }
    });

    toolbarHoverZone.addEventListener('pointerleave', e => {
      if (e.pointerType === 'pen') {
        hideToolbar();
      }
    });

    // Keep toolbar visible while hovering over it
    toolbar.addEventListener('pointerenter', e => {
      if (e.pointerType === 'pen') {
        cancelHide();
      }
    });

    toolbar.addEventListener('pointerleave', e => {
      if (e.pointerType === 'pen') {
        hideToolbar();
      }
    });

    $('penTool').onclick = () => setTool('pen');
    $('eraserTool').onclick = () => setTool('eraser');
    $('lassoTool').onclick = () => setTool('lasso');
    $('sizeDown').onclick = () => { if (sizeIdx > 0) { width = sizes[--sizeIdx]; sizeVal.textContent = width; updateCursor(); } };
    $('sizeUp').onclick = () => { if (sizeIdx < sizes.length-1) { width = sizes[++sizeIdx]; sizeVal.textContent = width; updateCursor(); } };
    $('pressureBtn').onclick = () => { pressure = !pressure; $('pressureBtn').classList.toggle('active', pressure); };
    $('undoBtn').onclick = undo;
    $('redoBtn').onclick = redo;
    $('clearBtn').onclick = () => {
      if (strokes.length) {
        undoStack.push(...strokes.reverse());
        strokes = [];
        group.innerHTML = '';
        savePageAnnotations();
      }
    };

    // PDF controls
    $('pdfBtn').onclick = () => pdfInput.click();

    pdfInput.onchange = async e => {
      const file = e.target.files[0];
      if (file) {
        await loadPDF(file);
      }
      pdfInput.value = '';
    };

    $('prevPage').onclick = () => goToPage(currentPage - 1);
    $('nextPage').onclick = () => goToPage(currentPage + 1);
    $('closePdf').onclick = closePDF;

    container.addEventListener('pointerdown', start);
    container.addEventListener('pointermove', move);
    container.addEventListener('pointerup', stop);
    container.addEventListener('pointerleave', stop);
    container.addEventListener('pointercancel', stop);
    container.addEventListener('contextmenu', e => e.preventDefault());

    // Two-finger swipe for PDF page navigation
    let touchStartX = 0;
    let touchStartY = 0;
    let isTwoFingerTouch = false;

    container.addEventListener('touchstart', e => {
      if (e.touches.length === 2 && pdfDoc) {
        isTwoFingerTouch = true;
        touchStartX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
        touchStartY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
        e.preventDefault();
      } else {
        isTwoFingerTouch = false;
        e.preventDefault();
      }
    }, { passive: false });

    container.addEventListener('touchmove', e => {
      e.preventDefault();
    }, { passive: false });

    container.addEventListener('touchend', e => {
      if (isTwoFingerTouch && pdfDoc) {
        const touchEndX = e.changedTouches[0].clientX;
        const touchEndY = e.changedTouches[0].clientY;
        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;
        const swipeThreshold = 80; // Minimum horizontal distance
        const verticalTolerance = 0.5; // Allow up to 50% vertical vs horizontal

        // Check if swipe is primarily horizontal
        const isHorizontal = Math.abs(deltaY) < Math.abs(deltaX) * verticalTolerance;

        if (Math.abs(deltaX) > swipeThreshold && isHorizontal) {
          if (deltaX > 0) {
            goToPage(currentPage - 1); // Swipe right = previous page
          } else {
            goToPage(currentPage + 1); // Swipe left = next page
          }
        }
        isTwoFingerTouch = false;
      }
    }, { passive: false });

    window.addEventListener('resize', resize);

    document.addEventListener('keydown', e => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); e.shiftKey ? redo() : undo(); }
      if (e.key === 'p' || e.key === 'P') setTool('pen');
      if (e.key === 'e' || e.key === 'E') setTool('eraser');
      if (e.key === 'l' || e.key === 'L') setTool('lasso');
      if (e.key === '[') $('sizeDown').click();
      if (e.key === ']') $('sizeUp').click();
      if (e.key === 'ArrowLeft' && pdfDoc) goToPage(currentPage - 1);
      if (e.key === 'ArrowRight' && pdfDoc) goToPage(currentPage + 1);
      if ((e.key === 'Delete' || e.key === 'Backspace') && selectedStrokes.length > 0) {
        e.preventDefault();
        deleteSelectedStrokes();
      }
    });

    sizeVal.style.color = color;
    updateCursor();
    resize();
  </script>
</body>
</html>
