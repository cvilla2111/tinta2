<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Delegated Ink Trail with DPR Detection</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      overflow: hidden;
      background: #ffffff;
    }

    canvas {
      display: block;
      touch-action: none;
    }

    #dpr-info {
      position: fixed;
      bottom: 1rem;
      left: 1rem;
      padding: 0.5rem 1rem;
      background: rgba(0, 0, 0, 0.05);
      backdrop-filter: blur(10px);
      border-radius: 6px;
      font-family: 'SF Mono', 'Fira Code', monospace;
      font-size: 12px;
      color: rgba(0, 0, 0, 0.7);
      z-index: 10;
    }

    #dpr-info span {
      color: #009944;
      font-weight: bold;
    }

    #toolbar-trigger {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 20px;
      z-index: 100;
    }

    #toolbar {
      position: fixed;
      top: -60px;
      left: 0;
      right: 0;
      height: 60px;
      background: rgba(0, 0, 0, 0.08);
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      z-index: 99;
      transition: top 0.3s ease;
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    }

    #toolbar-trigger:hover + #toolbar,
    #toolbar:hover {
      top: 0;
    }

    #toolbar label {
      font-family: 'SF Mono', 'Fira Code', monospace;
      font-size: 14px;
      color: rgba(0, 0, 0, 0.7);
    }

    .stepper {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .stepper button {
      width: 36px;
      height: 36px;
      border: none;
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.1);
      color: rgba(0, 0, 0, 0.7);
      font-size: 20px;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .stepper button:hover {
      background: rgba(0, 0, 0, 0.2);
    }

    .stepper button:active {
      background: rgba(0, 0, 0, 0.3);
    }

    .stepper-value {
      min-width: 50px;
      text-align: center;
      font-family: 'SF Mono', 'Fira Code', monospace;
      font-size: 16px;
      font-weight: bold;
      color: #000000;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 4px;
      transition: background 0.2s ease;
    }

    .stepper-value:hover {
      background: rgba(0, 0, 0, 0.1);
    }

    #color-popup {
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border-radius: 8px;
      padding: 12px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
      display: none;
      flex-direction: column;
      gap: 10px;
      z-index: 200;
      border: 1px solid rgba(0, 0, 0, 0.1);
    }

    #color-popup.show {
      display: flex;
    }

    .color-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .color-row label {
      font-family: 'SF Mono', 'Fira Code', monospace;
      font-size: 12px;
      color: rgba(0, 0, 0, 0.7);
      min-width: 55px;
    }

    .color-row input[type="color"] {
      width: 32px;
      height: 24px;
      border: 1px solid rgba(0, 0, 0, 0.2);
      border-radius: 4px;
      cursor: pointer;
      padding: 0;
    }

    .stepper-wrapper {
      position: relative;
    }

    .toggle-container {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-left: 1rem;
      padding-left: 1rem;
      border-left: 1px solid rgba(0, 0, 0, 0.15);
    }

    .toggle-switch {
      position: relative;
      width: 44px;
      height: 24px;
      background: rgba(0, 0, 0, 0.15);
      border-radius: 12px;
      cursor: pointer;
      transition: background 0.3s ease;
    }

    .toggle-switch::after {
      content: '';
      position: absolute;
      top: 2px;
      left: 2px;
      width: 20px;
      height: 20px;
      background: #fff;
      border-radius: 50%;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
      transition: transform 0.3s ease;
    }

    .toggle-switch.active {
      background: #009944;
    }

    .toggle-switch.active::after {
      transform: translateX(20px);
    }

    .stabilizer-container {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-left: 1rem;
      padding-left: 1rem;
      border-left: 1px solid rgba(0, 0, 0, 0.15);
    }

    .bezier-container {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-left: 1rem;
      padding-left: 1rem;
      border-left: 1px solid rgba(0, 0, 0, 0.15);
    }

    .bezier-controls {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      opacity: 0.4;
      pointer-events: none;
      transition: opacity 0.2s ease;
    }

    .bezier-controls.active {
      opacity: 1;
      pointer-events: auto;
    }

    #eraser-indicator {
      position: fixed;
      pointer-events: none;
      border: 1px solid rgba(0, 0, 0, 0.5);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      display: none;
      z-index: 1000;
    }
  </style>
</head>
<body>
  <div id="toolbar-trigger"></div>
  <div id="toolbar">
    <label>Pen Size:</label>
    <div class="stepper">
      <button id="size-decrease">−</button>
      <div class="stepper-wrapper">
        <span id="size-value" class="stepper-value">2.5</span>
        <div id="color-popup">
          <div class="color-row">
            <label>Pen:</label>
            <input type="color" id="pen-color-picker" value="#000000">
          </div>
          <div class="color-row">
            <label>Preview:</label>
            <input type="color" id="preview-color-picker" value="#000000">
          </div>
        </div>
      </div>
      <button id="size-increase">+</button>
    </div>
    <div class="toggle-container">
      <label>Pressure:</label>
      <div id="pressure-toggle" class="toggle-switch"></div>
    </div>
    <div class="stabilizer-container">
      <label>Stabilizer:</label>
      <div class="stepper">
        <button id="stabilizer-decrease">−</button>
        <span id="stabilizer-value" class="stepper-value">0.0</span>
        <button id="stabilizer-increase">+</button>
      </div>
    </div>
    <div class="bezier-container">
      <label>Bezier:</label>
      <div id="bezier-toggle" class="toggle-switch"></div>
      <div id="bezier-controls" class="bezier-controls">
        <div class="stepper">
          <button id="bezier-decrease">−</button>
          <span id="bezier-value" class="stepper-value">3</span>
          <button id="bezier-increase">+</button>
        </div>
      </div>
    </div>
  </div>
  <canvas id="canvas"></canvas>
  <div id="eraser-indicator"></div>
  <div id="dpr-info">Device Pixel Ratio: <span id="dpr-value">1</span></div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const dprValueEl = document.getElementById('dpr-value');

    // DPR Detection
    let dpr = window.devicePixelRatio || 1;

    function setupCanvas() {
      // Get the current DPR
      dpr = window.devicePixelRatio || 1;
      dprValueEl.textContent = dpr.toFixed(2);

      // Get the display size
      const displayWidth = window.innerWidth;
      const displayHeight = window.innerHeight;

      // Set the canvas buffer size accounting for DPR
      canvas.width = Math.floor(displayWidth * dpr);
      canvas.height = Math.floor(displayHeight * dpr);

      // Set the CSS display size
      canvas.style.width = displayWidth + 'px';
      canvas.style.height = displayHeight + 'px';

      // Scale the context to account for DPR
      ctx.scale(dpr, dpr);
    }

    // Initial setup
    setupCanvas();

    // Handle resize and DPR changes
    window.addEventListener('resize', setupCanvas);

    // Listen for DPR changes (e.g., moving window between monitors)
    if (window.matchMedia) {
      const mediaQuery = window.matchMedia(`(resolution: ${dpr}dppx)`);
      mediaQuery.addEventListener('change', () => {
        setupCanvas();
      });
    }

    // Ink presenter setup
    let presenter = null;
    if (navigator.ink) {
      navigator.ink.requestPresenter({ presentationArea: canvas })
        .then(p => { presenter = p; })
        .catch(err => console.log('Ink API not supported:', err));
    }

    let strokeColor = '#000000';
    let strokeWidth = 2.5;
    const previewStyle = { color: '#000000', diameter: strokeWidth };
    const sizeValueEl = document.getElementById('size-value');
    const colorPopup = document.getElementById('color-popup');
    const penColorPicker = document.getElementById('pen-color-picker');
    const previewColorPicker = document.getElementById('preview-color-picker');
    const pressureToggle = document.getElementById('pressure-toggle');
    let pressureEnabled = false;

    // Stabilizer settings
    const stabilizerValueEl = document.getElementById('stabilizer-value');
    let stabilizerStrength = 0; // 0 = off, 0.1-10 = strength
    let brushX = 0;
    let brushY = 0;
    let targetX = 0;
    let targetY = 0;
    let stabilizerAnimationId = null;

    function updateStabilizerDisplay() {
      stabilizerValueEl.textContent = stabilizerStrength.toFixed(1);
    }

    // Stabilizer stepper controls
    document.getElementById('stabilizer-decrease').addEventListener('click', () => {
      if (stabilizerStrength > 0) {
        stabilizerStrength = Math.round((stabilizerStrength - 0.1) * 10) / 10;
        if (stabilizerStrength < 0) stabilizerStrength = 0;
        updateStabilizerDisplay();
      }
    });

    document.getElementById('stabilizer-increase').addEventListener('click', () => {
      if (stabilizerStrength < 10) {
        stabilizerStrength = Math.round((stabilizerStrength + 0.1) * 10) / 10;
        updateStabilizerDisplay();
      }
    });

    // Bezier smoothing settings
    const bezierToggle = document.getElementById('bezier-toggle');
    const bezierControls = document.getElementById('bezier-controls');
    const bezierValueEl = document.getElementById('bezier-value');
    let bezierEnabled = false;
    let bezierSmoothness = 3; // Number of points to collect before drawing (2-10)
    let pointBuffer = []; // Buffer to collect points for bezier curve

    // Toggle bezier smoothing
    bezierToggle.addEventListener('click', () => {
      bezierEnabled = !bezierEnabled;
      bezierToggle.classList.toggle('active', bezierEnabled);
      bezierControls.classList.toggle('active', bezierEnabled);
    });

    // Bezier smoothness stepper controls
    document.getElementById('bezier-decrease').addEventListener('click', () => {
      if (bezierSmoothness > 2) {
        bezierSmoothness--;
        bezierValueEl.textContent = bezierSmoothness;
      }
    });

    document.getElementById('bezier-increase').addEventListener('click', () => {
      if (bezierSmoothness < 10) {
        bezierSmoothness++;
        bezierValueEl.textContent = bezierSmoothness;
      }
    });

    // Draw smooth curve using quadratic midpoint interpolation
    function drawSmoothCurve(points, lineWidth) {
      if (points.length < 2) return;

      ctx.strokeStyle = strokeColor;
      ctx.lineWidth = lineWidth;
      ctx.beginPath();

      // Start from the first point
      ctx.moveTo(points[0].x, points[0].y);

      if (points.length === 2) {
        // Just two points - draw a line
        ctx.lineTo(points[1].x, points[1].y);
      } else {
        // Quadratic midpoint interpolation:
        // Draw lines to midpoints, using actual points as control points
        for (let i = 0; i < points.length - 1; i++) {
          const p0 = points[i];
          const p1 = points[i + 1];

          // Calculate midpoint between current and next point
          const midX = (p0.x + p1.x) / 2;
          const midY = (p0.y + p1.y) / 2;

          if (i === 0) {
            // First segment: line to first midpoint
            ctx.lineTo(midX, midY);
          } else {
            // Subsequent segments: quadratic curve using previous point as control
            ctx.quadraticCurveTo(p0.x, p0.y, midX, midY);
          }
        }

        // Final segment: curve to the last point
        const lastPoint = points[points.length - 1];
        ctx.lineTo(lastPoint.x, lastPoint.y);
      }

      ctx.stroke();
    }

    // Toggle pressure sensitivity
    pressureToggle.addEventListener('click', () => {
      pressureEnabled = !pressureEnabled;
      pressureToggle.classList.toggle('active', pressureEnabled);
    });

    // Toggle color popup when clicking size value
    sizeValueEl.addEventListener('click', (evt) => {
      evt.stopPropagation();
      colorPopup.classList.toggle('show');
    });

    // Close popup when clicking outside
    document.addEventListener('click', (evt) => {
      if (!colorPopup.contains(evt.target) && evt.target !== sizeValueEl) {
        colorPopup.classList.remove('show');
      }
    });

    // Prevent popup from closing when interacting with color pickers
    colorPopup.addEventListener('click', (evt) => {
      evt.stopPropagation();
    });

    // Update pen stroke color
    penColorPicker.addEventListener('input', (evt) => {
      strokeColor = evt.target.value;
      sizeValueEl.style.color = strokeColor;
    });

    // Update preview stroke color
    previewColorPicker.addEventListener('input', (evt) => {
      previewStyle.color = evt.target.value;
    });

    // Pen size stepper controls
    document.getElementById('size-decrease').addEventListener('click', () => {
      if (strokeWidth > 0.5) {
        strokeWidth = Math.round((strokeWidth - 0.5) * 10) / 10;
        sizeValueEl.textContent = strokeWidth;
        previewStyle.diameter = strokeWidth;
      }
    });

    document.getElementById('size-increase').addEventListener('click', () => {
      strokeWidth = Math.round((strokeWidth + 0.5) * 10) / 10;
      sizeValueEl.textContent = strokeWidth;
      previewStyle.diameter = strokeWidth;
    });
    let isPenDown = false;
    let isErasing = false;
    let lastX = 0;
    let lastY = 0;
    const defaultEraserSize = 20;
    const bigEraserSize = defaultEraserSize * 6;
    let currentEraserSize = defaultEraserSize;
    let eraserTapCount = 0;
    let lastEraserTapTime = 0;
    const tapTimeWindow = 500; // ms between taps to count as consecutive
    const eraserIndicator = document.getElementById('eraser-indicator');
    eraserIndicator.style.width = currentEraserSize + 'px';
    eraserIndicator.style.height = currentEraserSize + 'px';

    // Set up stroke style
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = strokeWidth;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    // Stabilizer animation loop - runs while drawing
    let currentPressure = 0.5;

    function stabilizerLoop() {
      if (!isPenDown || isErasing || stabilizerStrength === 0) {
        stabilizerAnimationId = null;
        return;
      }

      // Calculate distance to target
      const dx = targetX - brushX;
      const dy = targetY - brushY;
      const dist = Math.sqrt(dx * dx + dy * dy);

      // Only draw if brush has moved enough
      if (dist > 0.5) {
        // Move brush toward target - lower values = more smoothing
        const catchUp = 1 / (stabilizerStrength + 1);
        const newBrushX = brushX + dx * catchUp;
        const newBrushY = brushY + dy * catchUp;

        // Calculate pressure-based width
        const currentWidth = pressureEnabled
          ? strokeWidth * (0.2 + currentPressure * 1.6)
          : strokeWidth;

        // Draw from old brush position to new
        ctx.strokeStyle = strokeColor;
        ctx.lineWidth = currentWidth;
        ctx.beginPath();
        ctx.moveTo(brushX, brushY);
        ctx.lineTo(newBrushX, newBrushY);
        ctx.stroke();

        // Update brush position
        lastX = brushX;
        lastY = brushY;
        brushX = newBrushX;
        brushY = newBrushY;
      }

      stabilizerAnimationId = requestAnimationFrame(stabilizerLoop);
    }

    canvas.addEventListener('pointerdown', (evt) => {
      if (evt.pointerType === 'pen') {
        isPenDown = true;
        // Check if using eraser end (button 32 = eraser)
        isErasing = (evt.buttons & 32) !== 0;
        lastX = evt.pageX;
        lastY = evt.pageY;

        // Initialize stabilizer brush position
        brushX = lastX;
        brushY = lastY;
        targetX = lastX;
        targetY = lastY;
        currentPressure = evt.pressure || 0.5;

        // Reset bezier point buffer
        pointBuffer = [{ x: lastX, y: lastY, pressure: currentPressure }];

        ctx.beginPath();
        ctx.moveTo(lastX, lastY);

        // Start stabilizer loop if stabilizer is active
        if (stabilizerStrength > 0 && !isErasing) {
          if (!stabilizerAnimationId) {
            stabilizerAnimationId = requestAnimationFrame(stabilizerLoop);
          }
        }

        if (isErasing) {
          const now = Date.now();
          // Check if tap is within time window
          if (now - lastEraserTapTime < tapTimeWindow) {
            eraserTapCount++;
          } else {
            eraserTapCount = 1;
          }
          lastEraserTapTime = now;

          // Activate big eraser on 3 taps
          if (eraserTapCount >= 3) {
            currentEraserSize = bigEraserSize;
            eraserIndicator.style.borderColor = 'red';
          }

          eraserIndicator.style.width = currentEraserSize + 'px';
          eraserIndicator.style.height = currentEraserSize + 'px';
          eraserIndicator.style.display = 'block';
          eraserIndicator.style.left = evt.pageX + 'px';
          eraserIndicator.style.top = evt.pageY + 'px';
        }
      }
    });

    function resetEraser() {
      currentEraserSize = defaultEraserSize;
      eraserIndicator.style.width = currentEraserSize + 'px';
      eraserIndicator.style.height = currentEraserSize + 'px';
      eraserIndicator.style.borderColor = 'rgba(0, 0, 0, 0.5)';
      eraserIndicator.style.display = 'none';
    }

    function finishStabilizerStroke() {
      // Draw remaining stroke from brush to target
      if (stabilizerStrength > 0) {
        const currentWidth = pressureEnabled
          ? strokeWidth * (0.2 + currentPressure * 1.6)
          : strokeWidth;

        ctx.strokeStyle = strokeColor;
        ctx.lineWidth = currentWidth;
        ctx.beginPath();
        ctx.moveTo(brushX, brushY);
        ctx.lineTo(targetX, targetY);
        ctx.stroke();
      }

      // Flush remaining bezier buffer
      if (bezierEnabled && pointBuffer.length >= 2) {
        const avgPressure = pointBuffer.reduce((sum, p) => sum + p.pressure, 0) / pointBuffer.length;
        const lineWidth = pressureEnabled
          ? strokeWidth * (0.2 + avgPressure * 1.6)
          : strokeWidth;
        drawSmoothCurve(pointBuffer, lineWidth);
        pointBuffer = [];
      }

      // Cancel animation loop
      if (stabilizerAnimationId) {
        cancelAnimationFrame(stabilizerAnimationId);
        stabilizerAnimationId = null;
      }
    }

    canvas.addEventListener('pointerup', (evt) => {
      if (evt.pointerType === 'pen') {
        finishStabilizerStroke();
        isPenDown = false;
        if (isErasing) {
          resetEraser();
        }
        isErasing = false;
      }
    });

    canvas.addEventListener('pointerleave', (evt) => {
      if (evt.pointerType === 'pen') {
        finishStabilizerStroke();
        isPenDown = false;
        if (isErasing) {
          resetEraser();
        }
        isErasing = false;
      }
    });

    // Disable context menu on touch hold
    canvas.addEventListener('contextmenu', (evt) => {
      evt.preventDefault();
    });

    canvas.addEventListener('pointermove', async (evt) => {
      // Only respond to pen input when touching the screen
      if (evt.pointerType !== 'pen' || !isPenDown) return;

      const x = evt.pageX;
      const y = evt.pageY;

      if (isErasing) {
        // Eraser mode - erase strokes with filled circle
        ctx.save();
        ctx.globalCompositeOperation = 'destination-out';

        // Draw filled circles along the path for complete coverage
        const radius = currentEraserSize / 2;
        const dx = x - lastX;
        const dy = y - lastY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const steps = Math.max(1, Math.ceil(dist / (radius / 2)));

        for (let i = 0; i <= steps; i++) {
          const t = i / steps;
          const cx = lastX + dx * t;
          const cy = lastY + dy * t;
          ctx.beginPath();
          ctx.arc(cx, cy, radius, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.restore();

        // Update eraser indicator position
        eraserIndicator.style.left = x + 'px';
        eraserIndicator.style.top = y + 'px';
        lastX = x;
        lastY = y;
      } else if (stabilizerStrength > 0) {
        // Stabilizer mode - update target position, drawing happens in animation loop
        targetX = x;
        targetY = y;
        currentPressure = evt.pressure || 0.5;

        // Update ink presenter for low-latency preview (shows cursor position)
        if (presenter) {
          const previewDiameter = pressureEnabled
            ? strokeWidth * (0.2 + currentPressure * 1.6)
            : strokeWidth;
          presenter.updateInkTrailStartPoint(evt, {
            color: previewStyle.color,
            diameter: previewDiameter
          });
        }
      } else if (bezierEnabled) {
        // Bezier mode - collect points and draw smooth curves
        const pressure = evt.pressure || 0.5;
        pointBuffer.push({ x, y, pressure });

        // When buffer reaches threshold, draw bezier curve
        if (pointBuffer.length >= bezierSmoothness) {
          const avgPressure = pointBuffer.reduce((sum, p) => sum + p.pressure, 0) / pointBuffer.length;
          const lineWidth = pressureEnabled
            ? strokeWidth * (0.2 + avgPressure * 1.6)
            : strokeWidth;

          drawSmoothCurve(pointBuffer, lineWidth);

          // Keep last point as start of next segment for continuity
          const lastPoint = pointBuffer[pointBuffer.length - 1];
          pointBuffer = [lastPoint];
        }

        if (presenter) {
          const previewDiameter = pressureEnabled
            ? strokeWidth * (0.2 + pressure * 1.6)
            : strokeWidth;
          presenter.updateInkTrailStartPoint(evt, {
            color: previewStyle.color,
            diameter: previewDiameter
          });
        }

        lastX = x;
        lastY = y;
      } else {
        // No stabilizer, no bezier - draw directly
        const pressure = evt.pressure || 0.5;
        const lineWidth = pressureEnabled
          ? strokeWidth * (0.2 + pressure * 1.6)
          : strokeWidth;

        ctx.strokeStyle = strokeColor;
        ctx.lineWidth = lineWidth;
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(x, y);
        ctx.stroke();

        if (presenter) {
          const previewDiameter = pressureEnabled
            ? strokeWidth * (0.2 + pressure * 1.6)
            : strokeWidth;
          presenter.updateInkTrailStartPoint(evt, {
            color: previewStyle.color,
            diameter: previewDiameter
          });
        }

        lastX = x;
        lastY = y;
      }
    });
  </script>
</body>
</html>
