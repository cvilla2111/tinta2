<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Vector Canvas</title>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.min.mjs" type="module"></script>
  <style>
    :root { --bg: #fff; --border: #e5e7eb; --btn: #f3f4f6; --btn-hover: #e5e7eb; --active: #3b82f6; --text: #1f2937; --text2: #6b7280; }
    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html, body { width: 100%; height: 100%; overflow: hidden; font-family: 'IBM Plex Sans', -apple-system, sans-serif; background: var(--bg); touch-action: none; }

    /* Hover zone at top of screen */
    .toolbar-hover-zone { position: fixed; top: 0; left: 0; right: 0; height: 40px; z-index: 999; }

    /* Unified toolbar */
    .toolbar { position: fixed; top: 8px; left: 50%; transform: translateX(-50%); display: flex; align-items: center; gap: 4px; padding: 5px 8px; background: var(--bg); border: 1px solid var(--border); border-radius: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); z-index: 1000; transition: opacity 0.3s, transform 0.3s; }
    .toolbar.hidden { opacity: 0; transform: translateX(-50%) translateY(-100%); pointer-events: none; }

    .divider { width: 1px; height: 22px; background: var(--border); margin: 0 3px; }
    .tool-btn { width: 28px; height: 28px; border: none; background: var(--btn); border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s; }
    .tool-btn:hover { background: var(--btn-hover); }
    .tool-btn.active { background: var(--active); }
    .tool-btn.active svg { stroke: #fff; }
    .tool-btn svg { width: 14px; height: 14px; stroke: var(--text); stroke-width: 2; fill: none; }
    .stepper { display: flex; align-items: center; background: var(--btn); border-radius: 6px; overflow: hidden; }
    .stepper-btn { width: 22px; height: 22px; border: none; background: transparent; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: 600; color: var(--text); transition: background 0.15s; }
    .stepper-btn:hover { background: var(--btn-hover); }
    .stepper-btn:active { background: #d1d5db; }
    .stepper-value { min-width: 26px; text-align: center; font-size: 11px; font-weight: 600; padding: 0 2px; cursor: pointer; border-radius: 4px; transition: background 0.15s; }
    .stepper-value:hover { background: var(--btn-hover); }
    .color-modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center; z-index: 2000; opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s; }
    .color-modal-overlay.visible { opacity: 1; visibility: visible; }
    .color-modal { background: var(--bg); border-radius: 16px; padding: 20px; box-shadow: 0 8px 32px rgba(0,0,0,0.15); transform: scale(0.9); transition: transform 0.2s; }
    .color-modal-overlay.visible .color-modal { transform: scale(1); }
    .color-modal-title { font-size: 14px; font-weight: 600; color: var(--text); margin-bottom: 16px; text-align: center; }
    .color-modal-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 12px; }
    .color-modal-btn { width: 40px; height: 40px; border: 3px solid transparent; border-radius: 50%; cursor: pointer; transition: transform 0.15s, border-color 0.15s, box-shadow 0.15s; }
    .color-modal-btn:hover { transform: scale(1.15); box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
    .color-modal-btn.selected { border-color: var(--active); }
    .canvas-container { width: 100%; height: 100%; overflow: hidden; cursor: crosshair; position: relative; }
    .canvas-container.pdf-mode { overflow-y: auto; overflow-x: hidden; background: #d1d5db; display: flex; flex-direction: column; align-items: center; scrollbar-width: thin; scrollbar-color: rgba(0,0,0,0.2) transparent; }
    .canvas-container.pdf-mode::-webkit-scrollbar { width: 6px; }
    .canvas-container.pdf-mode::-webkit-scrollbar-track { background: transparent; }
    .canvas-container.pdf-mode::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.2); border-radius: 3px; }
    .canvas-container.pdf-mode::-webkit-scrollbar-thumb:hover { background: rgba(0,0,0,0.3); }
    .canvas-container.pdf-mode::before { content: ''; flex: 1; min-height: 0; }
    .canvas-container.pdf-mode::after { content: ''; flex: 1; min-height: 0; }
    .pdf-page-container { position: relative; flex-shrink: 0; }
    #pdf-canvas { display: block; pointer-events: none; }
    #drawing-svg { position: absolute; top: 0; left: 0; display: block; overflow: visible; }
    .canvas-container:not(.pdf-mode) .pdf-page-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
    .canvas-container:not(.pdf-mode) #pdf-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
    .canvas-container:not(.pdf-mode) #drawing-svg { width: 100%; height: 100%; }
    .stroke-path { stroke: none; }
    .eraser-cursor { position: fixed; pointer-events: none; border: 1px solid #666; border-radius: 50%; transform: translate(-50%, -50%); z-index: 999; display: none; }
    .eraser-cursor.big-eraser { border-color: #ef4444; border-width: 1.5px; }
    .canvas-container.eraser-mode { cursor: none; }
    .canvas-container.eraser-mode .eraser-cursor { display: block; }

    /* PDF Controls in unified toolbar */
    .pdf-controls { display: none; align-items: center; gap: 4px; }
    .pdf-controls.visible { display: flex; }
    .pdf-nav-btn { width: 28px; height: 28px; border: none; background: var(--btn); border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s; }
    .pdf-nav-btn:hover:not(:disabled) { background: var(--btn-hover); }
    .pdf-nav-btn:disabled { opacity: 0.4; cursor: not-allowed; }
    .pdf-nav-btn svg { width: 14px; height: 14px; stroke: var(--text); stroke-width: 2; fill: none; }
    .pdf-page-info { font-size: 11px; font-weight: 500; color: var(--text); min-width: 50px; text-align: center; }
    .pdf-close-btn { background: #ef4444; }
    .pdf-close-btn:hover { background: #dc2626; }
    .pdf-close-btn svg { stroke: #fff; }

    /* Loading state */
    .loading-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 4000; opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; }
    .loading-overlay.visible { opacity: 1; visibility: visible; }
    .loading-spinner { width: 48px; height: 48px; border: 4px solid rgba(255,255,255,0.3); border-top-color: #fff; border-radius: 50%; animation: spin 0.8s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Graph paper background for no-PDF state */
    .canvas-container.no-pdf {
      background-color: var(--bg);
      background-image:
        linear-gradient(rgba(59, 130, 246, 0.2) 1px, transparent 1px),
        linear-gradient(90deg, rgba(59, 130, 246, 0.2) 1px, transparent 1px);
      background-size: 20px 20px;
    }

    #pdfInput { display: none; }
  </style>
</head>
<body>
  <input type="file" id="pdfInput" accept="application/pdf">

  <!-- Invisible hover zone at top to trigger toolbar -->
  <div class="toolbar-hover-zone" id="toolbarHoverZone"></div>

  <div class="toolbar hidden" id="toolbar">
    <button class="tool-btn" id="pdfBtn" title="Open PDF">
      <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>
    </button>
    <div class="divider"></div>
    <button class="tool-btn active" id="penTool" title="Pen (P)"><svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/><circle cx="11" cy="11" r="2"/></svg></button>
    <button class="tool-btn" id="eraserTool" title="Eraser (E)"><svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><path d="M20 20H7L3 16c-.8-.8-.8-2 0-2.8L13.5 3a2 2 0 012.8 0L21 7.5a2 2 0 010 2.8L11 20"/><path d="M6.5 13.5L11 9"/></svg></button>
    <div class="divider"></div>
    <div class="stepper"><button class="stepper-btn" id="sizeDown">âˆ’</button><span class="stepper-value" id="sizeValue">5.5</span><button class="stepper-btn" id="sizeUp">+</button></div>
    <div class="divider"></div>
    <button class="tool-btn active" id="pressureBtn" title="Pressure Sensitivity"><svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83"/><circle cx="12" cy="12" r="3"/></svg></button>
    <div class="divider"></div>
    <button class="tool-btn" id="undoBtn" title="Undo (Ctrl+Z)"><svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><path d="M3 7v6h6"/><path d="M3 13a9 9 0 1 0 2.5-6.5L3 7"/></svg></button>
    <button class="tool-btn" id="redoBtn" title="Redo (Ctrl+Shift+Z)"><svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><path d="M21 7v6h-6"/><path d="M21 13a9 9 0 1 1-2.5-6.5L21 7"/></svg></button>
    <div class="divider"></div>
    <button class="tool-btn" id="clearBtn" title="Clear Page Annotations"><svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2"/><path d="M19 6l-1 14a2 2 0 01-2 2H8a2 2 0 01-2-2L5 6"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg></button>

    <!-- PDF Controls (shown when PDF is open) -->
    <div class="divider pdf-controls" id="pdfDivider"></div>
    <div class="pdf-controls" id="pdfControls">
      <button class="pdf-nav-btn" id="prevPage" title="Previous Page">
        <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"/></svg>
      </button>
      <span class="pdf-page-info" id="pageInfo">1 / 1</span>
      <button class="pdf-nav-btn" id="nextPage" title="Next Page">
        <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"/></svg>
      </button>
      <button class="pdf-nav-btn pdf-close-btn" id="closePdf" title="Close PDF">
        <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
      </button>
    </div>
  </div>

  <div class="color-modal-overlay" id="colorModalOverlay">
    <div class="color-modal">
      <div class="color-modal-title">Choose Color</div>
      <div class="color-modal-grid" id="colorModalGrid"></div>
    </div>
  </div>

  <div class="loading-overlay" id="loadingOverlay">
    <div class="loading-spinner"></div>
  </div>

  <div class="canvas-container no-pdf" id="canvasContainer">
    <div class="pdf-page-container" id="pdfPageContainer">
      <canvas id="pdf-canvas"></canvas>
      <svg id="drawing-svg" xmlns="http://www.w3.org/2000/svg"><g id="strokes-group"></g></svg>
    </div>
    <div class="eraser-cursor" id="eraserCursor"></div>
  </div>

  <script type="module">
    // Initialize PDF.js
    const pdfjsLib = await import('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.min.mjs');
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.worker.min.mjs';

    const dpr = window.devicePixelRatio || 1;
    const SEGMENT_MAX = 1200, BIG_ERASER_MULT = 6, TAP_THRESHOLD = 500;
    const sizes = Array.from({length: 63}, (_, i) => (i + 1) * 0.5);
    const colors = ['#1f2937','#6b7280','#ef4444','#f97316','#eab308','#22c55e','#14b8a6','#3b82f6','#8b5cf6','#ec4899'];

    let tool = 'pen', width = 5.5, color = '#1f2937', sizeIdx = 10, drawing = false, path = null, points = [];
    let strokes = [], undoStack = [];
    let eraserEnd = false, prevTool = 'pen', pressure = true, bigEraser = false, tapTimes = [], segLen = 0;

    // PDF state
    let pdfDoc = null, currentPage = 1, totalPages = 0;
    let pageAnnotations = {}; // Store annotations per page: { pageNum: { strokes: [], undoStack: [] } }

    // PDF coordinate system - used for fixed coordinate mapping
    let pdfPageWidth = 0, pdfPageHeight = 0;  // Native PDF page dimensions

    // Get effective stroke width (scaled for PDF mode)
    const getEffectiveWidth = () => {
      if (pdfDoc && pdfPageWidth > 0) {
        const containerWidth = container.getBoundingClientRect().width;
        const scale = pdfPageWidth / (containerWidth * dpr);
        return width * scale;
      }
      return width;
    };

    // Toolbar visibility state
    let toolbarVisible = false;
    let hideToolbarTimeout = null;

    const $ = id => document.getElementById(id);
    const svg = $('drawing-svg'), group = $('strokes-group'), container = $('canvasContainer');
    const cursor = $('eraserCursor'), sizeVal = $('sizeValue');
    const modal = $('colorModalOverlay'), grid = $('colorModalGrid');
    const pdfCanvas = $('pdf-canvas'), pdfCtx = pdfCanvas.getContext('2d');
    const loadingOverlay = $('loadingOverlay');
    const toolbar = $('toolbar'), pageInfo = $('pageInfo');
    const pdfInput = $('pdfInput');
    const pdfControls = $('pdfControls'), pdfDivider = $('pdfDivider');
    const toolbarHoverZone = $('toolbarHoverZone');

    // Show/hide toolbar functions
    const showToolbar = () => {
      toolbarVisible = true;
      toolbar.classList.remove('hidden');
      clearTimeout(hideToolbarTimeout);
    };

    const hideToolbar = () => {
      hideToolbarTimeout = setTimeout(() => {
        toolbarVisible = false;
        toolbar.classList.add('hidden');
      }, 300);
    };

    const cancelHide = () => {
      clearTimeout(hideToolbarTimeout);
    };

    // Initialize color palette
    colors.forEach(c => {
      const b = document.createElement('button');
      b.className = 'color-modal-btn' + (c === color ? ' selected' : '');
      b.style.background = c;
      b.dataset.color = c;
      b.onclick = () => {
        color = c;
        sizeVal.style.color = c;
        grid.querySelectorAll('.color-modal-btn').forEach(x => x.classList.toggle('selected', x.dataset.color === c));
        modal.classList.remove('visible');
      };
      grid.appendChild(b);
    });

    sizeVal.onclick = () => modal.classList.add('visible');
    modal.onclick = e => { if (e.target === modal) modal.classList.remove('visible'); };

    const setTool = t => {
      tool = t;
      $('penTool').classList.toggle('active', t === 'pen');
      $('eraserTool').classList.toggle('active', t === 'eraser');
      container.classList.toggle('eraser-mode', t === 'eraser');
      updateCursor();
    };

    const updateCursor = () => {
      // Cursor size in CSS pixels - diameter = width * 3 screen pixels
      const s = width * 3 * (bigEraser ? BIG_ERASER_MULT : 1);
      cursor.style.width = cursor.style.height = s + 'px';
      cursor.classList.toggle('big-eraser', bigEraser);
    };

    const checkTap = () => {
      const n = Date.now();
      tapTimes.push(n);
      tapTimes = tapTimes.filter(t => n - t < TAP_THRESHOLD);
      if (tapTimes.length >= 3) { bigEraser = true; tapTimes = []; updateCursor(); }
    };

    const resetBig = () => { if (bigEraser) { bigEraser = false; tapTimes = []; updateCursor(); } };

    // Save current page annotations
    const savePageAnnotations = () => {
      if (pdfDoc) {
        pageAnnotations[currentPage] = {
          strokes: strokes.map(s => ({ ...s })),
          undoStack: undoStack.map(s => ({ ...s }))
        };
      }
    };

    // Load page annotations
    const loadPageAnnotations = () => {
      group.innerHTML = '';
      const data = pageAnnotations[currentPage];
      if (data) {
        strokes = data.strokes.map(s => {
          const el = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          el.classList.add('stroke-path');
          el.setAttribute('fill', s.color);
          el.setAttribute('d', buildPath(s.points, s.width));
          group.appendChild(el);
          return { ...s, element: el };
        });
        undoStack = data.undoStack.map(s => {
          const el = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          el.classList.add('stroke-path');
          el.setAttribute('fill', s.color);
          el.setAttribute('d', buildPath(s.points, s.width));
          return { ...s, element: el };
        });
      } else {
        strokes = [];
        undoStack = [];
      }
    };

    const undo = () => {
      if (strokes.length) {
        const s = strokes.pop();
        undoStack.push(s);
        s.element.remove();
        savePageAnnotations();
      }
    };

    const redo = () => {
      if (undoStack.length) {
        const s = undoStack.pop();
        group.appendChild(s.element);
        strokes.push(s);
        savePageAnnotations();
      }
    };

    const isPen = e => e.pointerType === 'pen';
    const isEraser = e => e.button === 5 || (e.buttons & 32) !== 0;

    // Convert screen coordinates to SVG/PDF-space coordinates
    const getData = e => {
      const r = svg.getBoundingClientRect();

      if (pdfDoc && pdfPageWidth > 0) {
        // When PDF is loaded, SVG is sized to match PDF page
        // Convert screen coords to PDF page coords using the viewBox
        const x = ((e.clientX - r.left) / r.width) * pdfPageWidth;
        const y = ((e.clientY - r.top) / r.height) * pdfPageHeight;
        return { x, y, pressure: e.pressure ?? 0.5 };
      } else {
        // No PDF loaded, use screen coordinates with dpr
        return { x: (e.clientX - r.left) * dpr, y: (e.clientY - r.top) * dpr, pressure: e.pressure ?? 0.5 };
      }
    };

    function buildPath(pts, w) {
      if (pts.length < 2) {
        const p = pts[0], r = (w * p.pressure * 1.5) / 2;
        return `M${p.x-r},${p.y}a${r},${r} 0 1,0 ${r*2},0a${r},${r} 0 1,0 ${-r*2},0`;
      }
      const L = [], R = [];
      for (let i = 0; i < pts.length; i++) {
        const p = pts[i], pr = pressure ? Math.max(0.25, Math.pow(p.pressure, 0.75)) : 0.7, hw = (w * pr * 1.5) / 2;
        let dx, dy;
        if (i === 0) { dx = pts[1].x - p.x; dy = pts[1].y - p.y; }
        else if (i === pts.length - 1) { dx = p.x - pts[i-1].x; dy = p.y - pts[i-1].y; }
        else { dx = pts[i+1].x - pts[i-1].x; dy = pts[i+1].y - pts[i-1].y; }
        const len = Math.sqrt(dx*dx + dy*dy) || 1, nx = -dy/len, ny = dx/len;
        L.push({ x: p.x + nx*hw, y: p.y + ny*hw });
        R.push({ x: p.x - nx*hw, y: p.y - ny*hw });
      }
      let d = `M${L[0].x},${L[0].y}`;
      for (let i = 1; i < L.length; i++) d += `Q${L[i-1].x},${L[i-1].y},${(L[i-1].x+L[i].x)/2},${(L[i-1].y+L[i].y)/2}`;
      const ll = L[L.length-1], lr = R[R.length-1];
      d += `L${(ll.x+lr.x)/2},${(ll.y+lr.y)/2}`;
      for (let i = R.length-2; i >= 0; i--) d += `Q${R[i+1].x},${R[i+1].y},${(R[i+1].x+R[i].x)/2},${(R[i+1].y+R[i].y)/2}`;
      d += `Q${R[0].x},${R[0].y},${L[0].x},${L[0].y}Z`;
      return d;
    }

    const newPath = () => {
      path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.classList.add('stroke-path');
      path.setAttribute('fill', color);
      path.setAttribute('d', buildPath(points, getEffectiveWidth()));
      group.appendChild(path);
    };

    const finalize = () => {
      if (path && points.length > 1) {
        strokes.push({ element: path, points: [...points], color, width: getEffectiveWidth() });
        savePageAnnotations();
      }
    };

    const setCursor = e => {
      cursor.style.left = e.clientX + 'px';
      cursor.style.top = e.clientY + 'px';
    };

    function start(e) {
      if (!isPen(e)) return;
      if (isEraser(e)) {
        eraserEnd = true;
        prevTool = tool;
        if (tool !== 'eraser') setTool('eraser');
        checkTap();
        setCursor(e);
      } else {
        if (e.button && e.button !== 0) return;
        eraserEnd = false;
      }
      e.preventDefault();
      drawing = true;
      points = [];
      segLen = 0;
      undoStack = [];
      points.push(getData(e));
      if (tool === 'pen') newPath();
      if (tool === 'eraser') setCursor(e);
    }

    function move(e) {
      if (!isPen(e) || !drawing) return;
      e.preventDefault();
      const d = getData(e);
      if (tool === 'eraser') { setCursor(e); erase(d.x, d.y); return; }
      const last = points[points.length - 1], dist = Math.hypot(d.x - last.x, d.y - last.y);
      if (dist < 2) return;
      segLen += dist;
      points.push(d);
      path.setAttribute('d', buildPath(points, getEffectiveWidth()));
      if (segLen >= SEGMENT_MAX) {
        finalize();
        points = points.slice(-2);
        segLen = 0;
        newPath();
      }
    }

    function stop(e) {
      if (e && !isPen(e)) return;
      if (!drawing) return;
      drawing = false;
      if (tool === 'pen' && path) {
        strokes.push({ element: path, points: [...points], color, width: getEffectiveWidth() });
        savePageAnnotations();
        path = null;
      }
      points = [];
      if (eraserEnd) {
        eraserEnd = false;
        resetBig();
        if (prevTool !== 'eraser') setTool(prevTool);
      }
    }

    function erase(x, y) {
      // Eraser radius: multiply by dpr to get consistent screen-pixel size in both modes
      const r = getEffectiveWidth() * 1.5 * (bigEraser ? BIG_ERASER_MULT : 1) * dpr;
      let erased = false;
      for (let i = strokes.length - 1; i >= 0; i--) {
        const s = strokes[i], b = s.element.getBBox();
        if (x < b.x-r || x > b.x+b.width+r || y < b.y-r || y > b.y+b.height+r) continue;
        for (const p of s.points) {
          if (Math.hypot(x-p.x, y-p.y) < r + s.width) {
            s.element.remove();
            undoStack.push(strokes.splice(i,1)[0]);
            erased = true;
            break;
          }
        }
      }
      if (erased) savePageAnnotations();
    }

    // PDF rendering
    async function renderPage(pageNum) {
      if (!pdfDoc) return;

      const page = await pdfDoc.getPage(pageNum);
      const containerRect = container.getBoundingClientRect();
      const horizontalMargin = 30; // 15px left + 15px right

      // Get native PDF page dimensions
      const viewport = page.getViewport({ scale: 1 });
      pdfPageWidth = viewport.width;
      pdfPageHeight = viewport.height;

      // Calculate scale to fit WIDTH with margins
      const availableWidth = containerRect.width - horizontalMargin;
      const pdfScale = (availableWidth * dpr) / viewport.width;

      const scaledViewport = page.getViewport({ scale: pdfScale });

      // Set canvas size to fit the scaled page exactly
      const displayWidth = availableWidth;
      const displayHeight = scaledViewport.height / dpr;

      pdfCanvas.width = scaledViewport.width;
      pdfCanvas.height = scaledViewport.height;
      pdfCanvas.style.width = displayWidth + 'px';
      pdfCanvas.style.height = displayHeight + 'px';

      // Set the page container size
      const pageContainer = $('pdfPageContainer');
      pageContainer.style.width = displayWidth + 'px';
      pageContainer.style.height = displayHeight + 'px';

      // Clear and render (no offset needed - page fills width)
      pdfCtx.fillStyle = '#fff';
      pdfCtx.fillRect(0, 0, pdfCanvas.width, pdfCanvas.height);

      await page.render({
        canvasContext: pdfCtx,
        viewport: scaledViewport
      }).promise;

      // Set SVG viewBox to PDF page dimensions so strokes align with PDF content
      svg.setAttribute('viewBox', `0 0 ${pdfPageWidth} ${pdfPageHeight}`);

      // SVG fills the page container
      svg.style.width = '100%';
      svg.style.height = '100%';

      // Update page info
      pageInfo.textContent = `${pageNum} / ${totalPages}`;
      $('prevPage').disabled = pageNum <= 1;
      $('nextPage').disabled = pageNum >= totalPages;
    }

    async function loadPDF(file) {
      loadingOverlay.classList.add('visible');

      try {
        const arrayBuffer = await file.arrayBuffer();
        pdfDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        totalPages = pdfDoc.numPages;
        currentPage = 1;
        pageAnnotations = {};

        // Clear current drawings
        group.innerHTML = '';
        strokes = [];
        undoStack = [];

        container.classList.remove('no-pdf');
        container.classList.add('pdf-mode');

        // Show PDF controls in toolbar
        pdfControls.classList.add('visible');
        pdfDivider.classList.add('visible');

        await renderPage(1);
        loadPageAnnotations();
      } catch (err) {
        console.error('Error loading PDF:', err);
      } finally {
        loadingOverlay.classList.remove('visible');
      }
    }

    function closePDF() {
      pdfDoc = null;
      currentPage = 1;
      totalPages = 0;
      pageAnnotations = {};
      pdfPageWidth = 0;
      pdfPageHeight = 0;

      pdfCtx.clearRect(0, 0, pdfCanvas.width, pdfCanvas.height);
      group.innerHTML = '';
      strokes = [];
      undoStack = [];

      // Reset page container and SVG to full container size
      const pageContainer = $('pdfPageContainer');
      pageContainer.style.width = '';
      pageContainer.style.height = '';
      svg.style.width = '100%';
      svg.style.height = '100%';
      const r = container.getBoundingClientRect();
      svg.setAttribute('viewBox', `0 0 ${r.width * dpr} ${r.height * dpr}`);

      container.classList.remove('pdf-mode');
      container.classList.add('no-pdf');

      // Hide PDF controls in toolbar
      pdfControls.classList.remove('visible');
      pdfDivider.classList.remove('visible');
    }

    async function goToPage(pageNum) {
      if (!pdfDoc || pageNum < 1 || pageNum > totalPages) return;

      savePageAnnotations();
      currentPage = pageNum;
      await renderPage(pageNum);
      loadPageAnnotations();
      container.scrollTop = 0; // Scroll to top of new page
    }

    const resize = () => {
      const r = container.getBoundingClientRect();
      if (pdfDoc) {
        // Re-render PDF page - this will also update SVG positioning
        renderPage(currentPage);
      } else {
        // No PDF - SVG fills container
        svg.setAttribute('viewBox', `0 0 ${r.width * dpr} ${r.height * dpr}`);
      }
    };

    // Event listeners for toolbar hover zone (stylus only)
    toolbarHoverZone.addEventListener('pointerenter', e => {
      if (e.pointerType === 'pen') {
        showToolbar();
      }
    });

    toolbarHoverZone.addEventListener('pointerleave', e => {
      if (e.pointerType === 'pen') {
        hideToolbar();
      }
    });

    // Keep toolbar visible while hovering over it
    toolbar.addEventListener('pointerenter', e => {
      if (e.pointerType === 'pen') {
        cancelHide();
      }
    });

    toolbar.addEventListener('pointerleave', e => {
      if (e.pointerType === 'pen') {
        hideToolbar();
      }
    });

    $('penTool').onclick = () => setTool('pen');
    $('eraserTool').onclick = () => setTool('eraser');
    $('sizeDown').onclick = () => { if (sizeIdx > 0) { width = sizes[--sizeIdx]; sizeVal.textContent = width; updateCursor(); } };
    $('sizeUp').onclick = () => { if (sizeIdx < sizes.length-1) { width = sizes[++sizeIdx]; sizeVal.textContent = width; updateCursor(); } };
    $('pressureBtn').onclick = () => { pressure = !pressure; $('pressureBtn').classList.toggle('active', pressure); };
    $('undoBtn').onclick = undo;
    $('redoBtn').onclick = redo;
    $('clearBtn').onclick = () => {
      if (strokes.length) {
        undoStack.push(...strokes.reverse());
        strokes = [];
        group.innerHTML = '';
        savePageAnnotations();
      }
    };

    // PDF controls
    $('pdfBtn').onclick = () => pdfInput.click();

    pdfInput.onchange = async e => {
      const file = e.target.files[0];
      if (file) {
        await loadPDF(file);
      }
      pdfInput.value = '';
    };

    $('prevPage').onclick = () => goToPage(currentPage - 1);
    $('nextPage').onclick = () => goToPage(currentPage + 1);
    $('closePdf').onclick = closePDF;

    container.addEventListener('pointerdown', start);
    container.addEventListener('pointermove', move);
    container.addEventListener('pointermove', e => { if (isPen(e) && tool === 'eraser') setCursor(e); });
    container.addEventListener('pointerup', stop);
    container.addEventListener('pointerleave', stop);
    container.addEventListener('pointercancel', stop);
    container.addEventListener('contextmenu', e => e.preventDefault());

    // Two-finger swipe for PDF page navigation
    let touchStartX = 0;
    let touchStartY = 0;
    let isTwoFingerTouch = false;

    container.addEventListener('touchstart', e => {
      if (e.touches.length === 2 && pdfDoc) {
        isTwoFingerTouch = true;
        touchStartX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
        touchStartY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
        e.preventDefault();
      } else {
        isTwoFingerTouch = false;
        e.preventDefault();
      }
    }, { passive: false });

    container.addEventListener('touchmove', e => {
      e.preventDefault();
    }, { passive: false });

    container.addEventListener('touchend', e => {
      if (isTwoFingerTouch && pdfDoc) {
        const touchEndX = e.changedTouches[0].clientX;
        const touchEndY = e.changedTouches[0].clientY;
        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;
        const swipeThreshold = 80; // Minimum horizontal distance
        const verticalTolerance = 0.5; // Allow up to 50% vertical vs horizontal

        // Check if swipe is primarily horizontal
        const isHorizontal = Math.abs(deltaY) < Math.abs(deltaX) * verticalTolerance;

        if (Math.abs(deltaX) > swipeThreshold && isHorizontal) {
          if (deltaX > 0) {
            goToPage(currentPage - 1); // Swipe right = previous page
          } else {
            goToPage(currentPage + 1); // Swipe left = next page
          }
        }
        isTwoFingerTouch = false;
      }
    }, { passive: false });

    window.addEventListener('resize', resize);

    document.addEventListener('keydown', e => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); e.shiftKey ? redo() : undo(); }
      if (e.key === 'p' || e.key === 'P') setTool('pen');
      if (e.key === 'e' || e.key === 'E') setTool('eraser');
      if (e.key === '[') $('sizeDown').click();
      if (e.key === ']') $('sizeUp').click();
      if (e.key === 'ArrowLeft' && pdfDoc) goToPage(currentPage - 1);
      if (e.key === 'ArrowRight' && pdfDoc) goToPage(currentPage + 1);
    });

    sizeVal.style.color = color;
    updateCursor();
    resize();
  </script>
</body>
</html>
