<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Canvas</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: #fff; touch-action: none; }
    #canvas { display: block; width: 100%; height: 100%; cursor: crosshair; touch-action: none; }

    .toolbar-trigger { position: fixed; top: 0; left: 0; right: 0; height: 20px; z-index: 100; }

    .toolbar {
      position: fixed; top: 0; left: 0; right: 0; height: 56px;
      background: rgba(255,255,255,0.95); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
      border-bottom: 1px solid #e5e5e5; display: flex; align-items: center; justify-content: center;
      gap: 8px; padding: 0 16px; transform: translateY(-100%);
      transition: transform 0.25s cubic-bezier(0.4,0,0.2,1); z-index: 99; font-family: 'Inter', sans-serif;
    }
    .toolbar.visible { transform: translateY(0); }

    .toolbar-group { display: flex; align-items: center; gap: 4px; padding: 0 8px; border-right: 1px solid #e5e5e5; }
    .toolbar-group:last-child { border-right: none; }

    .tool-btn {
      width: 40px; height: 40px; border: none; background: transparent; border-radius: 8px;
      cursor: pointer; display: flex; align-items: center; justify-content: center;
      transition: all 0.15s ease; color: #555;
    }
    .tool-btn:hover { background: #f0f0f0; }
    .tool-btn.active { background: #333; color: #fff; }
    .tool-btn svg { width: 20px; height: 20px; }

    .eraser-cursor {
      position: fixed; pointer-events: none; border: 1px solid #888; border-radius: 50%;
      box-sizing: border-box; z-index: 50; display: none; transform: translate(-50%, -50%);
    }
    .eraser-cursor.visible { display: block; }
    .eraser-cursor.big { border-color: #e53935; border-width: 1.5px; }

    .stepper { display: flex; align-items: center; gap: 2px; }
    .stepper-btn {
      width: 32px; height: 32px; border: none; background: #f0f0f0; border-radius: 6px;
      cursor: pointer; display: flex; align-items: center; justify-content: center;
      transition: all 0.15s ease; color: #555; font-size: 18px; font-weight: 500; user-select: none;
    }
    .stepper-btn:hover { background: #e0e0e0; }
    .stepper-btn:active { background: #d0d0d0; transform: scale(0.95); }
    .stepper-value {
      min-width: 44px; height: 32px; display: flex; align-items: center; justify-content: center;
      font-size: 14px; font-weight: 500; border-radius: 6px; cursor: pointer;
      transition: all 0.15s ease; border: 2px solid #e5e5e5;
    }
    .stepper-value:hover { border-color: #ccc; transform: scale(1.05); }

    .pressure-indicator { font-size: 11px; color: #aaa; padding: 4px 8px; background: #f5f5f5; border-radius: 4px; }
  </style>
</head>
<body>
  <div class="toolbar-trigger" id="toolbarTrigger"></div>
  <div class="toolbar" id="toolbar">
    <div class="toolbar-group">
      <button class="tool-btn active" id="penBtn" title="Pen">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/>
          <path d="M2 2l7.586 7.586"/><circle cx="11" cy="11" r="2"/>
        </svg>
      </button>
      <button class="tool-btn" id="eraserBtn" title="Eraser">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M20 20H7L3 16c-.8-.8-.8-2 0-2.8L13.4 2.8c.8-.8 2-.8 2.8 0L21 7.6c.8.8.8 2 0 2.8L11 20"/>
          <path d="M6 11l6 6"/>
        </svg>
      </button>
    </div>
    <div class="toolbar-group">
      <input type="color" id="colorPicker" value="#000000" style="position:absolute;opacity:0;pointer-events:none;">
      <div class="stepper">
        <button class="stepper-btn" id="strokeMinus" title="Decrease stroke">âˆ’</button>
        <div class="stepper-value" id="strokeValue" title="Click to change color" style="color:#000;">2</div>
        <button class="stepper-btn" id="strokePlus" title="Increase stroke">+</button>
      </div>
    </div>
    <div class="toolbar-group">
      <button class="tool-btn" id="undoBtn" title="Undo">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M3 7v6h6"/><path d="M3 13c0-4.97 4.03-9 9-9s9 4.03 9 9-4.03 9-9 9a9 9 0 0 1-6.36-2.64"/>
        </svg>
      </button>
      <button class="tool-btn" id="redoBtn" title="Redo">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M21 7v6h-6"/><path d="M21 13c0-4.97-4.03-9-9-9s-9 4.03-9 9 4.03 9 9 9a9 9 0 0 0 6.36-2.64"/>
        </svg>
      </button>
    </div>
    <div class="toolbar-group">
      <button class="tool-btn" id="clearBtn" title="Clear All">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="3 6 5 6 21 6"/>
          <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
          <line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/>
        </svg>
      </button>
    </div>
    <div class="toolbar-group">
      <span class="pressure-indicator" id="pressureIndicator">Pressure: --</span>
    </div>
  </div>
  <canvas id="canvas"></canvas>
  <div class="eraser-cursor" id="eraserCursor"></div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const toolbar = document.getElementById('toolbar');
    const toolbarTrigger = document.getElementById('toolbarTrigger');
    const eraserCursor = document.getElementById('eraserCursor');
    const penBtn = document.getElementById('penBtn');
    const eraserBtn = document.getElementById('eraserBtn');
    const colorPicker = document.getElementById('colorPicker');
    const strokeValue = document.getElementById('strokeValue');
    const pressureIndicator = document.getElementById('pressureIndicator');

    let isDrawing = false, lastX = 0, lastY = 0;
    let currentTool = 'pen', currentColor = '#000000', strokeWidth = 2;
    const baseEraserSize = 20;
    let eraserSize = baseEraserSize, bigEraserActive = false;
    let pressure = 0.5, dpr = 1, usingPenEraser = false;
    let eraserTapCount = 0, eraserTapTimeout = null;
    const tapInterval = 400;
    let history = [], historyIndex = -1;
    const maxHistory = 50;
    let toolbarTimeout;

    function setupCanvas() {
      dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      ctx.scale(dpr, dpr);
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      if (history.length > 0 && historyIndex >= 0) {
        const img = new Image();
        img.onload = () => ctx.drawImage(img, 0, 0, rect.width, rect.height);
        img.src = history[historyIndex];
      }
    }

    function saveState() {
      historyIndex++;
      history = history.slice(0, historyIndex);
      history.push(canvas.toDataURL());
      if (history.length > maxHistory) { history.shift(); historyIndex--; }
    }

    function getCoords(e) {
      const rect = canvas.getBoundingClientRect();
      return { x: e.clientX - rect.left, y: e.clientY - rect.top };
    }

    function isEraserButton(e) {
      return e.button === 5 || (e.buttons & 32) !== 0;
    }

    function getEffectiveTool(e) {
      return (isEraserButton(e) || usingPenEraser) ? 'eraser' : currentTool;
    }

    function handleEraserTap() {
      eraserTapCount++;
      clearTimeout(eraserTapTimeout);
      if (eraserTapCount >= 3) {
        bigEraserActive = true;
        eraserSize = baseEraserSize * 6;
        eraserTapCount = 0;
      } else {
        eraserTapTimeout = setTimeout(() => eraserTapCount = 0, tapInterval);
      }
    }

    function resetBigEraserSize() {
      if (bigEraserActive) { bigEraserActive = false; eraserSize = baseEraserSize; }
    }

    function resetBigEraserFull() {
      resetBigEraserSize();
      eraserTapCount = 0;
      clearTimeout(eraserTapTimeout);
    }

    function getStrokeWidth(p) { return strokeWidth * (0.5 + p); }

    function updateEraserCursor(e, show) {
      if (show) {
        eraserCursor.style.cssText = `width:${eraserSize}px;height:${eraserSize}px;left:${e.clientX}px;top:${e.clientY}px`;
        eraserCursor.classList.add('visible');
        eraserCursor.classList.toggle('big', bigEraserActive);
      } else {
        eraserCursor.classList.remove('visible', 'big');
      }
    }

    function updateStrokeDisplay() {
      strokeValue.textContent = strokeWidth % 1 === 0 ? strokeWidth : strokeWidth.toFixed(1);
      strokeValue.style.color = currentColor;
    }

    function startDrawing(e) {
      if (e.pointerType === 'touch') return;
      usingPenEraser = isEraserButton(e);
      const isUsingEraser = usingPenEraser || currentTool === 'eraser';
      isUsingEraser ? handleEraserTap() : resetBigEraserFull();

      isDrawing = true;
      const coords = getCoords(e);
      lastX = coords.x; lastY = coords.y;
      pressure = e.pressure || 0.5;
      pressureIndicator.textContent = `Pressure: ${Math.round(pressure * 100)}%`;

      const tool = getEffectiveTool(e);
      ctx.beginPath();
      if (tool === 'eraser') {
        ctx.globalCompositeOperation = 'destination-out';
        ctx.arc(lastX, lastY, eraserSize / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalCompositeOperation = 'source-over';
      } else {
        ctx.arc(lastX, lastY, getStrokeWidth(pressure) / 2, 0, Math.PI * 2);
        ctx.fillStyle = currentColor;
        ctx.fill();
      }
    }

    function draw(e) {
      if (!isDrawing || e.pointerType === 'touch') return;
      const coords = getCoords(e);
      pressure = e.pressure || 0.5;
      pressureIndicator.textContent = `Pressure: ${Math.round(pressure * 100)}%`;

      const tool = getEffectiveTool(e);
      ctx.beginPath();
      ctx.moveTo(lastX, lastY);
      ctx.lineTo(coords.x, coords.y);

      if (tool === 'eraser') {
        ctx.globalCompositeOperation = 'destination-out';
        ctx.lineWidth = eraserSize;
        ctx.stroke();
        ctx.globalCompositeOperation = 'source-over';
      } else {
        ctx.strokeStyle = currentColor;
        ctx.lineWidth = getStrokeWidth(pressure);
        ctx.stroke();
      }
      lastX = coords.x; lastY = coords.y;
    }

    function stopDrawing() {
      if (isDrawing) {
        isDrawing = false;
        resetBigEraserSize();
        usingPenEraser = false;
        saveState();
      }
    }

    function restoreState(index) {
      const img = new Image();
      img.onload = () => {
        const rect = canvas.getBoundingClientRect();
        ctx.clearRect(0, 0, rect.width, rect.height);
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, rect.width, rect.height);
        ctx.drawImage(img, 0, 0, rect.width, rect.height);
      };
      img.src = history[index];
    }

    // Initialize
    setupCanvas();
    saveState();

    // Event listeners
    window.addEventListener('resize', () => {
      const imageData = canvas.toDataURL();
      setupCanvas();
      const img = new Image();
      img.onload = () => {
        const rect = canvas.getBoundingClientRect();
        ctx.drawImage(img, 0, 0, rect.width, rect.height);
      };
      img.src = imageData;
    });

    toolbarTrigger.addEventListener('pointerenter', () => { clearTimeout(toolbarTimeout); toolbar.classList.add('visible'); });
    toolbar.addEventListener('pointerenter', () => { clearTimeout(toolbarTimeout); toolbar.classList.add('visible'); });
    toolbar.addEventListener('pointerleave', () => { toolbarTimeout = setTimeout(() => toolbar.classList.remove('visible'), 1500); });

    canvas.addEventListener('pointerdown', startDrawing);
    canvas.addEventListener('pointermove', (e) => {
      draw(e);
      updateEraserCursor(e, getEffectiveTool(e) === 'eraser' || currentTool === 'eraser');
    });
    canvas.addEventListener('pointerup', stopDrawing);
    canvas.addEventListener('pointerout', (e) => { stopDrawing(); updateEraserCursor(e, false); });
    canvas.addEventListener('pointercancel', stopDrawing);
    canvas.addEventListener('pointerleave', (e) => updateEraserCursor(e, false));
    canvas.addEventListener('pointerenter', (e) => updateEraserCursor(e, getEffectiveTool(e) === 'eraser' || currentTool === 'eraser'));

    ['touchstart', 'touchmove', 'touchend'].forEach(evt => canvas.addEventListener(evt, e => e.preventDefault(), { passive: false }));
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    penBtn.addEventListener('click', () => { currentTool = 'pen'; penBtn.classList.add('active'); eraserBtn.classList.remove('active'); });
    eraserBtn.addEventListener('click', () => { currentTool = 'eraser'; eraserBtn.classList.add('active'); penBtn.classList.remove('active'); });

    strokeValue.addEventListener('click', () => colorPicker.click());
    colorPicker.addEventListener('input', (e) => { currentColor = e.target.value; updateStrokeDisplay(); });
    document.getElementById('strokeMinus').addEventListener('click', () => { if (strokeWidth > 0.5) { strokeWidth = Math.round((strokeWidth - 0.5) * 10) / 10; updateStrokeDisplay(); } });
    document.getElementById('strokePlus').addEventListener('click', () => { if (strokeWidth < 50) { strokeWidth = Math.round((strokeWidth + 0.5) * 10) / 10; updateStrokeDisplay(); } });

    document.getElementById('undoBtn').addEventListener('click', () => { if (historyIndex > 0) { historyIndex--; restoreState(historyIndex); } });
    document.getElementById('redoBtn').addEventListener('click', () => { if (historyIndex < history.length - 1) { historyIndex++; restoreState(historyIndex); } });
    document.getElementById('clearBtn').addEventListener('click', () => {
      const rect = canvas.getBoundingClientRect();
      ctx.clearRect(0, 0, rect.width, rect.height);
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, rect.width, rect.height);
      saveState();
    });

    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey || e.metaKey) {
        if (e.key === 'z') { e.preventDefault(); document.getElementById('undoBtn').click(); }
        else if (e.key === 'y') { e.preventDefault(); document.getElementById('redoBtn').click(); }
      }
    });
  </script>
</body>
</html>
