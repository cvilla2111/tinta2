<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#4a8ea1">
  <title>Canvas</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #fff;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }

    #canvas {
      cursor: crosshair;
      touch-action: none;
      display: block;
    }

    .canvas-container {
      width: 100%;
      height: 100%;
      overflow: auto;
      position: absolute;
      top: 0;
      left: 0;
    }

    /* Minimal toolbar - toggle visibility with button */
    .toolbar {
      position: fixed;
      top: -70px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      padding: 10px 16px;
      background: rgba(30, 30, 30, 0.9);
      border-radius: 0 0 12px 12px;
      backdrop-filter: blur(10px);
      transition: top 0.3s ease;
      z-index: 100;
    }

    .toolbar.visible {
      top: 0;
    }

    .btn {
      width: 32px;
      height: 32px;
      border: none;
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s;
      font-size: 16px;
    }

    .btn:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .btn.active {
      background: rgba(255, 255, 255, 0.3);
    }

    .color-btn {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: 2px solid transparent;
      cursor: pointer;
      transition: transform 0.15s, border-color 0.15s;
    }

    .color-btn:hover {
      transform: scale(1.15);
    }

    .color-btn.active {
      border-color: #fff;
    }

    .separator {
      width: 1px;
      background: rgba(255, 255, 255, 0.2);
      margin: 0 4px;
    }

    .size-indicator {
      color: rgba(255, 255, 255, 0.7);
      font-size: 11px;
      font-family: system-ui, sans-serif;
      min-width: 28px;
      text-align: center;
      align-self: center;
    }

    /* Eraser cursor indicator */
    .eraser-cursor {
      position: fixed;
      border: 2px solid rgba(0, 0, 0, 0.5);
      border-radius: 50%;
      pointer-events: none;
      z-index: 1000;
      display: none;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.2);
    }

    .eraser-cursor.visible {
      display: block;
    }

    /* Lasso selection overlay */
    #lassoCanvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 10;
    }

    /* Selection indicator */
    .selection-box {
      position: absolute;
      border: 2px dashed #4a8ea1;
      background: transparent;
      pointer-events: none;
      z-index: 11;
      display: none;
    }

    .selection-box.visible {
      display: block;
    }

    .selection-box.moving {
      cursor: move;
      /* pointer-events stays none - movement handled through canvas */
    }

    /* Toggle toolbar button */
    .toolbar-toggle {
      position: fixed;
      top: 12px;
      right: 12px;
      width: 32px;
      height: 32px;
      border: none;
      border-radius: 50%;
      background: transparent;
      color: #555;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 101;
      transition: color 0.2s;
    }

    .toolbar-toggle:hover {
      color: #333;
    }

    .toolbar-toggle svg {
      width: 20px;
      height: 20px;
    }

  </style>
</head>
<body>
  <div class="canvas-container">
    <canvas id="canvas"></canvas>
    <canvas id="lassoCanvas"></canvas>
    <div class="selection-box" id="selectionBox"></div>
  </div>
  <div class="eraser-cursor" id="eraserCursor"></div>

  <button class="toolbar-toggle" id="toolbarToggle" title="Toggle toolbar">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="0.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/></svg>
  </button>

  <div class="toolbar" id="toolbar">
    <!-- Colors -->
    <button class="color-btn active" style="background: #1a1a1a;" data-color="#1a1a1a" title="Black"></button>
    <button class="color-btn" style="background: #e74c3c;" data-color="#e74c3c" title="Red"></button>
    <button class="color-btn" style="background: #3498db;" data-color="#3498db" title="Blue"></button>
    <button class="color-btn" style="background: #27ae60;" data-color="#27ae60" title="Green"></button>

    <div class="separator"></div>

    <!-- Size controls -->
    <button class="btn" id="sizeDown" title="Smaller">−</button>
    <span class="size-indicator" id="sizeDisplay">2</span>
    <button class="btn" id="sizeUp" title="Larger">+</button>

    <div class="separator"></div>

    <!-- Tools -->
    <button class="btn" id="eraserBtn" title="Eraser">⌫</button>
    <button class="btn" id="clearBtn" title="Clear All">✕</button>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', {
      willReadFrequently: false,
      desynchronized: true
    });

    // State
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    let lastPressure = 0.5;
    let strokeColor = '#1a1a1a';
    let baseSize = 2;
    let isEraser = false;
    let activeEraser = false; // True during stroke if using eraser tip or eraser tool

    // Double-tap eraser boost
    let eraserSizeMultiplier = 1;
    let eraserTapCount = 0;
    let lastEraserLiftTime = 0;
    let eraserResetTimeout = null;
    const DOUBLE_TAP_THRESHOLD = 150; // ms between taps to count as double-tap

    // Eraser cursor indicator
    const eraserCursor = document.getElementById('eraserCursor');

    // Lasso tool state
    const lassoCanvas = document.getElementById('lassoCanvas');
    const lassoCtx = lassoCanvas.getContext('2d');
    const selectionBox = document.getElementById('selectionBox');
    let isLassoMode = false;
    let isLassoDrawing = false;
    let lassoPath = []; // Array of {x, y} points
    let hasSelection = false;
    let selectionImageData = null;
    let selectionBounds = null; // {x, y, width, height}
    let isMovingSelection = false;
    let moveStartX = 0;
    let moveStartY = 0;
    let selectionOffsetX = 0;
    let selectionOffsetY = 0;

    // Detect stylus barrel button (button 2 / right click on pen)
    function isBarrelButton(e) {
      return e.button === 2 || (e.buttons & 2) !== 0;
    }

    function updateEraserCursor(x, y, show) {
      if (show) {
        const size = (getStrokeWidth(0.5) + 10) * 2 * eraserSizeMultiplier;
        eraserCursor.style.width = size + 'px';
        eraserCursor.style.height = size + 'px';
        eraserCursor.style.left = x + 'px';
        eraserCursor.style.top = y + 'px';
        eraserCursor.classList.add('visible');
        // Change border color when boosted
        eraserCursor.style.borderColor = eraserSizeMultiplier > 1 ? 'rgba(255, 100, 100, 0.8)' : 'rgba(0, 0, 0, 0.5)';
      } else {
        eraserCursor.classList.remove('visible');
      }
    }

    // Fixed canvas size with High DPI support
    function initCanvas() {
      const dpr = window.devicePixelRatio || 1;
      // Use initial viewport size as fixed canvas size
      const width = window.innerWidth;
      const height = window.innerHeight;

      canvas.width = width * dpr;
      canvas.height = height * dpr;

      ctx.scale(dpr, dpr);
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';

      // Canvas is transparent - white background handled by CSS
      ctx.clearRect(0, 0, width, height);
    }

    initCanvas();
    // No resize listener - canvas stays fixed

    // Initialize lasso canvas to same size
    function initLassoCanvas() {
      const dpr = window.devicePixelRatio || 1;
      const width = parseInt(canvas.style.width);
      const height = parseInt(canvas.style.height);
      lassoCanvas.width = width * dpr;
      lassoCanvas.height = height * dpr;
      lassoCtx.scale(dpr, dpr);
      lassoCanvas.style.width = width + 'px';
      lassoCanvas.style.height = height + 'px';
    }
    initLassoCanvas();

    // Clear lasso overlay
    function clearLassoCanvas() {
      const width = parseInt(lassoCanvas.style.width);
      const height = parseInt(lassoCanvas.style.height);
      lassoCtx.clearRect(0, 0, width, height);
    }

    // Draw lasso path on overlay
    function drawLassoPath() {
      clearLassoCanvas();
      if (lassoPath.length < 2) return;

      lassoCtx.beginPath();
      lassoCtx.moveTo(lassoPath[0].x, lassoPath[0].y);
      for (let i = 1; i < lassoPath.length; i++) {
        lassoCtx.lineTo(lassoPath[i].x, lassoPath[i].y);
      }
      lassoCtx.strokeStyle = '#4a8ea1';
      lassoCtx.lineWidth = 2;
      lassoCtx.setLineDash([5, 5]);
      lassoCtx.stroke();
      lassoCtx.setLineDash([]);
    }

    // Get bounding box of lasso path
    function getLassoBounds() {
      if (lassoPath.length === 0) return null;
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (const p of lassoPath) {
        minX = Math.min(minX, p.x);
        minY = Math.min(minY, p.y);
        maxX = Math.max(maxX, p.x);
        maxY = Math.max(maxY, p.y);
      }
      return {
        x: Math.floor(minX),
        y: Math.floor(minY),
        width: Math.ceil(maxX - minX),
        height: Math.ceil(maxY - minY)
      };
    }

    // Create selection from lasso path
    function createSelection() {
      if (lassoPath.length < 3) {
        cancelSelection();
        return;
      }

      const bounds = getLassoBounds();
      if (!bounds || bounds.width < 5 || bounds.height < 5) {
        cancelSelection();
        return;
      }

      selectionBounds = bounds;
      const dpr = window.devicePixelRatio || 1;

      // Create a temporary canvas at full DPR resolution to preserve quality
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = bounds.width * dpr;
      tempCanvas.height = bounds.height * dpr;
      const tempCtx = tempCanvas.getContext('2d');

      // Scale context for DPR
      tempCtx.scale(dpr, dpr);

      // Create clipping path from lasso (in local CSS coordinates)
      tempCtx.beginPath();
      tempCtx.moveTo(lassoPath[0].x - bounds.x, lassoPath[0].y - bounds.y);
      for (let i = 1; i < lassoPath.length; i++) {
        tempCtx.lineTo(lassoPath[i].x - bounds.x, lassoPath[i].y - bounds.y);
      }
      tempCtx.closePath();
      tempCtx.clip();

      // Draw the main canvas content into the clipped area
      // Source is in actual canvas pixels (scaled by DPR), dest is in CSS pixels (but context is scaled)
      tempCtx.drawImage(
        canvas,
        bounds.x * dpr, bounds.y * dpr, bounds.width * dpr, bounds.height * dpr,
        0, 0, bounds.width, bounds.height
      );

      // Store the selection image
      selectionImageData = tempCanvas;

      // Clear the selected area from main canvas using the lasso path
      ctx.save();
      ctx.globalCompositeOperation = 'destination-out';
      ctx.beginPath();
      ctx.moveTo(lassoPath[0].x, lassoPath[0].y);
      for (let i = 1; i < lassoPath.length; i++) {
        ctx.lineTo(lassoPath[i].x, lassoPath[i].y);
      }
      ctx.closePath();
      ctx.fill();
      ctx.restore();

      // Show selection box
      selectionBox.style.left = bounds.x + 'px';
      selectionBox.style.top = bounds.y + 'px';
      selectionBox.style.width = bounds.width + 'px';
      selectionBox.style.height = bounds.height + 'px';
      selectionBox.classList.add('visible', 'moving');

      hasSelection = true;
      selectionOffsetX = 0;
      selectionOffsetY = 0;

      // Draw selection preview on lasso canvas
      drawSelectionPreview();

      // Clear lasso path display
      lassoPath = [];
    }

    // Draw selection preview on lasso canvas
    function drawSelectionPreview() {
      if (!hasSelection || !selectionImageData || !selectionBounds) return;

      clearLassoCanvas();
      const x = selectionBounds.x + selectionOffsetX;
      const y = selectionBounds.y + selectionOffsetY;

      // Draw the DPR-scaled selection image at the current position
      // Source is the full temp canvas, dest is in CSS pixels (lassoCtx is already scaled)
      lassoCtx.drawImage(
        selectionImageData,
        0, 0, selectionImageData.width, selectionImageData.height,
        x, y, selectionBounds.width, selectionBounds.height
      );
    }

    // Commit selection to main canvas
    function commitSelection() {
      if (!hasSelection || !selectionImageData || !selectionBounds) return;

      const x = selectionBounds.x + selectionOffsetX;
      const y = selectionBounds.y + selectionOffsetY;

      ctx.globalCompositeOperation = 'source-over';
      // Draw DPR-scaled selection back to main canvas (ctx is already scaled)
      ctx.drawImage(
        selectionImageData,
        0, 0, selectionImageData.width, selectionImageData.height,
        x, y, selectionBounds.width, selectionBounds.height
      );

      cancelSelection();
    }

    // Cancel/clear selection
    function cancelSelection() {
      hasSelection = false;
      selectionImageData = null;
      selectionBounds = null;
      lassoPath = [];
      selectionOffsetX = 0;
      selectionOffsetY = 0;
      selectionBox.classList.remove('visible', 'moving');
      clearLassoCanvas();
    }

    // Start lasso drawing
    function startLasso(e) {
      // If we have a selection, commit it first before starting new lasso
      if (hasSelection) {
        commitSelection();
      }

      isLassoDrawing = true;
      lassoPath = [];
      const pos = getPointerPos(e);
      lassoPath.push({ x: pos.x, y: pos.y });
      drawLassoPath();
    }

    // Continue lasso drawing
    function continueLasso(e) {
      if (!isLassoDrawing) return;

      const pos = getPointerPos(e);
      lassoPath.push({ x: pos.x, y: pos.y });
      drawLassoPath();
    }

    // End lasso drawing
    function endLasso() {
      if (!isLassoDrawing) return;
      isLassoDrawing = false;

      // Create selection from path
      createSelection();
    }

    // Tilt compensation factor (pixels per degree of tilt)
    // Adjust this value based on stylus geometry - higher values = more compensation
    const TILT_COMPENSATION = 0.04;

    function getPointerPos(e) {
      const rect = canvas.getBoundingClientRect();
      let x = e.clientX - rect.left;
      let y = e.clientY - rect.top;

      // Apply tilt compensation if tilt data is available
      // tiltX and tiltY are in degrees (-90 to 90)
      if (e.pointerType === 'pen' && typeof e.tiltX === 'number' && typeof e.tiltY === 'number') {
        // Compensate position based on tilt angle
        // When tilted, offset the position opposite to the tilt direction
        x -= e.tiltX * TILT_COMPENSATION;
        y -= e.tiltY * TILT_COMPENSATION;
      }

      return {
        x: x,
        y: y,
        pressure: e.pressure || 0.5
      };
    }

    // Detect if using eraser end of stylus (button 5 or buttons bitmask 32)
    function isEraserTip(e) {
      return e.button === 5 || (e.buttons & 32) !== 0;
    }

    function startStroke(e) {
      // Only allow pen (stylus) input - disable finger/touch
      if (e.pointerType === 'touch') return;

      // If we have an active selection, check if touching inside or outside
      if (hasSelection && selectionBounds) {
        const pos = getPointerPos(e);
        const x = selectionBounds.x + selectionOffsetX;
        const y = selectionBounds.y + selectionOffsetY;

        if (pos.x >= x && pos.x <= x + selectionBounds.width &&
            pos.y >= y && pos.y <= y + selectionBounds.height) {
          // Touch inside selection - start moving (with any input, not just barrel button)
          isMovingSelection = true;
          moveStartX = pos.x;
          moveStartY = pos.y;
          e.preventDefault();
          return;
        } else {
          // Touch outside selection - commit it only, don't start a stroke
          commitSelection();
          e.preventDefault();
          return;
        }
      }

      // Check for barrel button - activate lasso mode
      if (isBarrelButton(e)) {
        isLassoMode = true;
        startLasso(e);
        e.preventDefault();
        return;
      }

      isDrawing = true;
      activeEraser = isEraser || isEraserTip(e); // Use eraser if tool selected OR using eraser tip

      const pos = getPointerPos(e);
      lastX = pos.x;
      lastY = pos.y;
      lastPressure = pos.pressure;

      // Show eraser cursor
      updateEraserCursor(e.clientX, e.clientY, activeEraser);

      // Double-tap detection for eraser boost
      if (activeEraser) {
        // Clear any pending reset
        if (eraserResetTimeout) {
          clearTimeout(eraserResetTimeout);
          eraserResetTimeout = null;
        }

        const now = Date.now();
        const timeSinceLastLift = now - lastEraserLiftTime;

        // If this tap is within threshold of last lift, count it
        if (timeSinceLastLift < DOUBLE_TAP_THRESHOLD && lastEraserLiftTime > 0) {
          eraserTapCount++;
          // Boost eraser on double-tap
          if (eraserTapCount >= 2 && eraserSizeMultiplier === 1) {
            eraserSizeMultiplier = 4;
            updateEraserCursor(e.clientX, e.clientY, true); // Update cursor size
          }
        } else {
          // Too slow, reset tap count (but keep multiplier if already boosted)
          eraserTapCount = 1;
        }
      }

      // Set composite operation for eraser (destination-out removes pixels)
      if (activeEraser) {
        ctx.globalCompositeOperation = 'destination-out';
      } else {
        ctx.globalCompositeOperation = 'source-over';
      }

      ctx.beginPath();
      ctx.arc(pos.x, pos.y, getStrokeWidth(pos.pressure) / 2, 0, Math.PI * 2);
      ctx.fillStyle = activeEraser ? 'rgba(0,0,0,1)' : strokeColor;
      ctx.fill();
    }

    function continueStroke(e) {
      // Handle moving selection (can happen outside of lasso mode now)
      if (isMovingSelection && hasSelection) {
        const pos = getPointerPos(e);
        const dx = pos.x - moveStartX;
        const dy = pos.y - moveStartY;
        selectionOffsetX += dx;
        selectionOffsetY += dy;
        moveStartX = pos.x;
        moveStartY = pos.y;

        // Update selection box position
        selectionBox.style.left = (selectionBounds.x + selectionOffsetX) + 'px';
        selectionBox.style.top = (selectionBounds.y + selectionOffsetY) + 'px';

        drawSelectionPreview();
        return;
      }

      // Handle lasso drawing mode
      if (isLassoMode) {
        continueLasso(e);
        return;
      }

      if (!isDrawing) return;

      const pos = getPointerPos(e);
      const width = getStrokeWidth(pos.pressure);
      const lastWidth = getStrokeWidth(lastPressure);

      // Update eraser cursor position
      updateEraserCursor(e.clientX, e.clientY, activeEraser);

      // Keep eraser boosted while actively erasing - cancel any pending reset
      if (activeEraser && eraserResetTimeout) {
        clearTimeout(eraserResetTimeout);
        eraserResetTimeout = null;
      }

      ctx.beginPath();
      ctx.moveTo(lastX, lastY);
      ctx.lineTo(pos.x, pos.y);
      ctx.strokeStyle = activeEraser ? 'rgba(0,0,0,1)' : strokeColor;
      ctx.lineWidth = activeEraser ? ((width + lastWidth) / 2 + 10) * 2 * eraserSizeMultiplier : (width + lastWidth) / 2;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.stroke();

      lastX = pos.x;
      lastY = pos.y;
      lastPressure = pos.pressure;
    }

    function endStroke(scheduleReset = true) {
      // Handle end of moving selection
      if (isMovingSelection) {
        isMovingSelection = false;
        // Selection stays active - user can move again or touch outside to commit
        return;
      }

      // Handle lasso mode end
      if (isLassoMode) {
        endLasso();
        isLassoMode = false;
        return;
      }

      // Track eraser lift time and schedule reset
      if (activeEraser && scheduleReset) {
        lastEraserLiftTime = Date.now();

        // Schedule reset after threshold - if no new tap comes, reset everything
        eraserResetTimeout = setTimeout(() => {
          eraserSizeMultiplier = 1;
          eraserTapCount = 0;
          eraserResetTimeout = null;
        }, DOUBLE_TAP_THRESHOLD);
      }

      isDrawing = false;
      updateEraserCursor(0, 0, false); // Hide eraser cursor
    }

    function getStrokeWidth(pressure) {
      const minWidth = baseSize * 0.3;
      const maxWidth = baseSize * 2.5;
      return minWidth + (maxWidth - minWidth) * pressure;
    }

    canvas.addEventListener('pointerdown', startStroke);
    canvas.addEventListener('pointermove', (e) => {
      continueStroke(e);
      // Show eraser cursor on hover when eraser tool is selected
      if (!isDrawing && (isEraser || isEraserTip(e))) {
        updateEraserCursor(e.clientX, e.clientY, true);
      } else if (!isDrawing) {
        updateEraserCursor(0, 0, false);
      }
    });
    canvas.addEventListener('pointerup', () => endStroke(true));
    canvas.addEventListener('pointerleave', () => {
      endStroke(false); // Don't schedule reset on leave - only on actual lift
      updateEraserCursor(0, 0, false); // Hide cursor when leaving canvas
    });
    canvas.addEventListener('pointercancel', () => endStroke(false));

    canvas.addEventListener('touchstart', e => e.preventDefault(), { passive: false });
    canvas.addEventListener('touchmove', e => e.preventDefault(), { passive: false });

    // Prevent context menu on right-click (barrel button)
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    // Toolbar
    const toolbar = document.getElementById('toolbar');
    const colorBtns = document.querySelectorAll('.color-btn');
    const sizeDisplay = document.getElementById('sizeDisplay');
    const eraserBtn = document.getElementById('eraserBtn');

    colorBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        colorBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        strokeColor = btn.dataset.color;
        isEraser = false;
        eraserBtn.classList.remove('active');
      });
    });

    document.getElementById('sizeUp').addEventListener('click', () => {
      baseSize = Math.min(20, baseSize + 1);
      sizeDisplay.textContent = baseSize;
    });

    document.getElementById('sizeDown').addEventListener('click', () => {
      baseSize = Math.max(1, baseSize - 1);
      sizeDisplay.textContent = baseSize;
    });

    eraserBtn.addEventListener('click', () => {
      isEraser = !isEraser;
      eraserBtn.classList.toggle('active', isEraser);
      if (isEraser) {
        colorBtns.forEach(b => b.classList.remove('active'));
      } else {
        document.querySelector(`[data-color="${strokeColor}"]`)?.classList.add('active');
      }
    });

    document.getElementById('clearBtn').addEventListener('click', () => {
      const rect = canvas.getBoundingClientRect();
      ctx.globalCompositeOperation = 'source-over';
      ctx.clearRect(0, 0, rect.width, rect.height);
    });

    toolbar.addEventListener('pointerdown', e => e.stopPropagation());

    // Toolbar toggle button
    const toolbarToggle = document.getElementById('toolbarToggle');
    toolbarToggle.addEventListener('click', () => {
      toolbar.classList.toggle('visible');
    });
    toolbarToggle.addEventListener('pointerdown', e => e.stopPropagation());

    // Keyboard shortcuts
    document.addEventListener('keydown', e => {
      if (e.key === 'Escape') {
        // Cancel selection or lasso
        if (hasSelection) {
          // Put selection back at original position
          selectionOffsetX = 0;
          selectionOffsetY = 0;
          commitSelection();
        } else if (isLassoDrawing) {
          isLassoDrawing = false;
          isLassoMode = false;
          cancelSelection();
        }
      } else if (e.key === 'e' || e.key === 'E') {
        eraserBtn.click();
      } else if (e.key === 'c' || e.key === 'C') {
        document.getElementById('clearBtn').click();
      } else if (e.key === '[') {
        document.getElementById('sizeDown').click();
      } else if (e.key === ']') {
        document.getElementById('sizeUp').click();
      } else if (e.key >= '1' && e.key <= '4') {
        const idx = parseInt(e.key) - 1;
        if (colorBtns[idx]) colorBtns[idx].click();
      } else if (e.key === 'Enter' && hasSelection) {
        // Commit selection on Enter
        commitSelection();
      }
    });
  </script>
</body>
</html>
