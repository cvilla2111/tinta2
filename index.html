<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#ffffff">
  <title>Vector Canvas</title>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.min.mjs" type="module"></script>
  <style>
    :root { --bg: #fff; --border: #e5e7eb; --btn: #f3f4f6; --btn-hover: #e5e7eb; --active: #3b82f6; --text: #1f2937; --text2: #6b7280; }
    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html, body { width: 100%; height: 100%; overflow: hidden; font-family: 'IBM Plex Sans', -apple-system, sans-serif; background: var(--bg); touch-action: none; }
    .menu-btn { position: fixed; top: 12px; right: 12px; width: 36px; height: 36px; border: none; background: transparent; cursor: pointer; display: flex; align-items: center; justify-content: center; z-index: 1001; }
    .menu-btn svg { width: 24px; height: 24px; stroke: #9ca3af; stroke-width: 1; fill: none; }
    .toolbar { position: fixed; top: 8px; left: 50%; transform: translateX(-50%); display: flex; align-items: center; gap: 4px; padding: 5px 8px; background: var(--bg); border: 1px solid var(--border); border-radius: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); z-index: 1000; transition: opacity 0.3s, transform 0.3s; }
    .toolbar.hidden { opacity: 0; transform: translateX(-50%) translateY(-100%); pointer-events: none; }
    .divider { width: 1px; height: 22px; background: var(--border); margin: 0 3px; }
    .tool-btn { width: 28px; height: 28px; border: none; background: var(--btn); border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s; }
    .tool-btn:hover { background: var(--btn-hover); }
    .tool-btn.active { background: var(--active); }
    .tool-btn.active svg { stroke: #fff; }
    .tool-btn svg { width: 14px; height: 14px; stroke: var(--text); stroke-width: 2; fill: none; }
    .stepper { display: flex; align-items: center; background: var(--btn); border-radius: 6px; overflow: hidden; }
    .stepper-btn { width: 22px; height: 22px; border: none; background: transparent; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: 600; color: var(--text); transition: background 0.15s; }
    .stepper-btn:hover { background: var(--btn-hover); }
    .stepper-btn:active { background: #d1d5db; }
    .stepper-value { min-width: 26px; text-align: center; font-size: 11px; font-weight: 600; padding: 0 2px; cursor: pointer; border-radius: 4px; transition: background 0.15s; }
    .stepper-value:hover { background: var(--btn-hover); }
    .color-modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center; z-index: 2000; opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s; }
    .color-modal-overlay.visible { opacity: 1; visibility: visible; }
    .color-modal { background: var(--bg); border-radius: 16px; padding: 20px; box-shadow: 0 8px 32px rgba(0,0,0,0.15); transform: scale(0.9); transition: transform 0.2s; }
    .color-modal-overlay.visible .color-modal { transform: scale(1); }
    .color-modal-title { font-size: 14px; font-weight: 600; color: var(--text); margin-bottom: 16px; text-align: center; }
    .color-modal-grid { display: grid; grid-template-columns: repeat(6, 1fr); gap: 12px; }
    .color-modal-btn { width: 40px; height: 40px; border: 3px solid transparent; border-radius: 50%; cursor: pointer; transition: transform 0.15s, border-color 0.15s, box-shadow 0.15s; }
    .color-modal-btn:hover { transform: scale(1.15); box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
    .color-modal-btn.selected { border-color: var(--active); }
    .color-modal-btn.white-color { border-color: #d1d5db; }
    .color-modal-btn.white-color.selected { border-color: var(--active); }
    .canvas-container { width: 100%; height: 100%; overflow: hidden; cursor: crosshair; position: relative; -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; }
    .canvas-container.pdf-mode { overflow-y: auto; overflow-x: hidden; background: #fff; display: flex; flex-direction: column; align-items: center; scrollbar-width: thin; scrollbar-color: rgba(0,0,0,0.2) transparent; touch-action: none; }
    .canvas-container.pdf-mode::-webkit-scrollbar { width: 6px; }
    .canvas-container.pdf-mode::-webkit-scrollbar-track { background: transparent; }
    .canvas-container.pdf-mode::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.2); border-radius: 3px; }
    .canvas-container.pdf-mode::-webkit-scrollbar-thumb:hover { background: rgba(0,0,0,0.3); }
    .canvas-container.pdf-mode::before, .canvas-container.pdf-mode::after { content: ''; flex: 1; min-height: 0; }
    .canvas-container.no-pdf { background-color: var(--bg); background-image: linear-gradient(rgba(59, 130, 246, 0.2) 1px, transparent 1px), linear-gradient(90deg, rgba(59, 130, 246, 0.2) 1px, transparent 1px); background-size: 20px 20px; }
    .canvas-container.lasso-mode { cursor: crosshair; }
    .canvas-container.eraser-mode { cursor: none; }
    .canvas-container.eraser-mode .eraser-cursor { display: block; }
    .pdf-page-container { position: relative; flex-shrink: 0; transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.25s cubic-bezier(0.4, 0, 0.2, 1); }
    .pdf-page-container.slide-out-left { transform: translateX(-100%); opacity: 0; }
    .pdf-page-container.slide-out-right { transform: translateX(100%); opacity: 0; }
    .pdf-page-container.slide-in-left { transform: translateX(100%); opacity: 0; transition: none; }
    .pdf-page-container.slide-in-right { transform: translateX(-100%); opacity: 0; transition: none; }
    .canvas-container:not(.pdf-mode) .pdf-page-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
    .canvas-container:not(.pdf-mode) #pdf-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
    .canvas-container:not(.pdf-mode) #drawing-svg { width: 100%; height: 100%; }
    #pdf-canvas { display: block; pointer-events: none; }
    #drawing-svg { position: absolute; top: 0; left: 0; display: block; overflow: visible; }
    #pdfInput { display: none; }
    .stroke-path { stroke: none; }
    .lasso-path { fill: none; stroke: var(--active); stroke-width: 2.5; stroke-dasharray: 6 4; }
    .selection-box { fill: none; stroke: var(--active); stroke-width: 2; stroke-dasharray: 5 3; }
    .selection-handle { fill: #fff; stroke: var(--active); stroke-width: 1.5; cursor: nwse-resize; }
    .rotation-handle { fill: #fff; stroke: var(--active); stroke-width: 1.5; cursor: grab; }
    .rotation-line { stroke: var(--active); stroke-width: 1.5; }
    .duplicate-handle { fill: #fff; stroke: var(--active); stroke-width: 1.5; cursor: pointer; }
    .duplicate-handle:hover { fill: var(--active); }
    .duplicate-handle:hover + .duplicate-icon { stroke: #fff; }
    .eraser-cursor { position: fixed; pointer-events: none; border: 1px solid #666; border-radius: 50%; transform: translate(-50%, -50%); z-index: 999; display: none; }
    .eraser-cursor.big-eraser { border-color: #ef4444; border-width: 1.5px; }
    .palette-btn { position: fixed; bottom: 8px; left: 8px; width: 28px; height: 28px; border: none; background: transparent; cursor: pointer; display: flex; align-items: center; justify-content: center; z-index: 1001; padding: 0; margin: 0; }
    .palette-btn svg { width: 22px; height: 22px; stroke: #9ca3af; stroke-width: 1; fill: none; }
    .color-carousel { position: fixed; bottom: 30px; left: 30px; width: 0; height: 0; z-index: 1000; pointer-events: none; }
    .color-carousel.visible { pointer-events: auto; }
    .color-carousel-hitarea { position: absolute; width: 240px; height: 240px; left: -20px; bottom: -20px; pointer-events: none; clip-path: polygon(0% 100%, 0% 0%, 100% 0%, 100% 100%, 50% 100%, 0% 50%); border-radius: 0 100% 0 0; }
    .color-carousel.visible .color-carousel-hitarea { pointer-events: auto; }
    .color-carousel-item { position: absolute; width: 40px; height: 40px; border-radius: 50%; cursor: pointer; border: 3px solid transparent; transform: scale(0) translate(0, 0); opacity: 0; transition: transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.25s ease-out, border-color 0.15s, box-shadow 0.15s; box-shadow: 0 2px 8px rgba(0,0,0,0.15); }
    .color-carousel.visible .color-carousel-item { transform: scale(1); }
    .color-carousel-item:hover { box-shadow: 0 4px 16px rgba(0,0,0,0.25); }
    .color-carousel-item.selected { border-color: #fff; box-shadow: 0 0 0 2px var(--active), 0 4px 16px rgba(0,0,0,0.3); }
    .color-carousel-item.white-color { border-color: #d1d5db; }
    .color-carousel-item.white-color.selected { border-color: #fff; box-shadow: 0 0 0 2px var(--active), 0 4px 16px rgba(0,0,0,0.3); }
    .pdf-controls { display: none; align-items: center; gap: 4px; }
    .pdf-controls.visible { display: flex; }
    .pdf-nav-btn { width: 28px; height: 28px; border: none; background: var(--btn); border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s; }
    .pdf-nav-btn:hover:not(:disabled) { background: var(--btn-hover); }
    .pdf-nav-btn:disabled { opacity: 0.4; cursor: not-allowed; }
    .pdf-nav-btn svg { width: 14px; height: 14px; stroke: var(--text); stroke-width: 2; fill: none; }
    .pdf-page-info { font-size: 11px; font-weight: 500; color: var(--text); min-width: 50px; text-align: center; }
    .pdf-close-btn { background: #ef4444; }
    .pdf-close-btn:hover { background: #dc2626; }
    .pdf-close-btn svg { stroke: #fff; }
    .loading-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 4000; opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; }
    .loading-overlay.visible { opacity: 1; visibility: visible; }
    .loading-spinner { width: 48px; height: 48px; border: 4px solid rgba(255,255,255,0.3); border-top-color: #fff; border-radius: 50%; animation: spin 0.8s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .filmstrip-overlay { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.85); display: flex; align-items: center; justify-content: center; z-index: 3000; opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; }
    .filmstrip-overlay.visible { opacity: 1; visibility: visible; }
    .filmstrip-container { display: flex; align-items: center; gap: 16px; padding: 20px 30px; max-width: 90vw; overflow-x: auto; overflow-y: hidden; scrollbar-width: thin; scrollbar-color: rgba(255,255,255,0.3) transparent; }
    .filmstrip-container::-webkit-scrollbar { height: 6px; }
    .filmstrip-container::-webkit-scrollbar-track { background: transparent; }
    .filmstrip-container::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.3); border-radius: 3px; }
    .filmstrip-container::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.5); }
    .filmstrip-item { flex-shrink: 0; cursor: pointer; border: 3px solid transparent; border-radius: 8px; overflow: hidden; transition: transform 0.2s, border-color 0.2s, box-shadow 0.2s; position: relative; background: #fff; }
    .filmstrip-item:hover { transform: scale(1.05); box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4); }
    .filmstrip-item.active { border-color: var(--active); box-shadow: 0 0 0 2px var(--active), 0 8px 24px rgba(59, 130, 246, 0.4); }
    .filmstrip-item canvas { display: block; height: 220px; width: auto; }
    .filmstrip-item-number { position: absolute; bottom: 6px; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.7); color: #fff; font-size: 11px; font-weight: 600; padding: 2px 8px; border-radius: 10px; }
    .filmstrip-placeholder { width: 156px; height: 220px; display: flex; align-items: center; justify-content: center; background: #e5e7eb; color: #6b7280; font-size: 12px; font-weight: 500; }
    .filmstrip-hint { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); color: rgba(255, 255, 255, 0.6); font-size: 12px; font-weight: 500; }

  </style>
</head>
<body>
  <input type="file" id="pdfInput" accept="application/pdf">
  <button class="palette-btn" id="paletteBtn" title="Color Picker">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22a1 1 0 0 1 0-20 10 9 0 0 1 10 9 5 5 0 0 1-5 5h-2.25a1.75 1.75 0 0 0-1.4 2.8l.3.4a1.75 1.75 0 0 1-1.4 2.8z"/><circle cx="13.5" cy="6.5" r=".5" fill="currentColor"/><circle cx="17.5" cy="10.5" r=".5" fill="currentColor"/><circle cx="6.5" cy="12.5" r=".5" fill="currentColor"/><circle cx="8.5" cy="7.5" r=".5" fill="currentColor"/></svg>
  </button>
  <div class="color-carousel" id="colorCarousel"><div class="color-carousel-hitarea" id="carouselHitarea"></div></div>
  <button class="menu-btn" id="menuBtn" title="Menu">
    <svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><path d="M13.77 3.043a34 34 0 0 0-3.54 0"/><path d="M13.771 20.956a33 33 0 0 1-3.541.001"/><path d="M20.18 17.74c-.51 1.15-1.29 1.93-2.439 2.44"/><path d="M20.18 6.259c-.51-1.148-1.291-1.929-2.44-2.438"/><path d="M20.957 10.23a33 33 0 0 1 0 3.54"/><path d="M3.043 10.23a34 34 0 0 0 .001 3.541"/><path d="M6.26 20.179c-1.15-.508-1.93-1.29-2.44-2.438"/><path d="M6.26 3.82c-1.149.51-1.93 1.291-2.44 2.44"/></svg>
  </button>
  <div class="toolbar hidden" id="toolbar">
    <button class="tool-btn" id="pdfBtn" title="Open PDF"><svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg></button>
    <div class="divider"></div>
    <button class="tool-btn active" id="penTool" title="Pen (P)"><svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/><circle cx="11" cy="11" r="2"/></svg></button>
    <button class="tool-btn" id="eraserTool" title="Eraser (E)"><svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><path d="M20 20H7L3 16c-.8-.8-.8-2 0-2.8L13.5 3a2 2 0 012.8 0L21 7.5a2 2 0 010 2.8L11 20"/><path d="M6.5 13.5L11 9"/></svg></button>
    <button class="tool-btn" id="lassoTool" title="Lasso Select (L)"><svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2C6.5 2 2 6.5 2 12c0 3.5 1.8 6.5 4.5 8.3"/><path d="M12 2c5.5 0 10 4.5 10 10 0 2.5-.9 4.8-2.4 6.5"/><path d="M8.5 21.5c1.1.3 2.3.5 3.5.5"/><circle cx="12" cy="19" r="2"/><path d="M12 21v2"/></svg></button>
    <div class="divider"></div>
    <div class="stepper"><button class="stepper-btn" id="sizeDown">−</button><span class="stepper-value" id="sizeValue">5.5</span><button class="stepper-btn" id="sizeUp">+</button></div>
    <div class="divider"></div>
    <button class="tool-btn active" id="pressureBtn" title="Pressure Sensitivity"><svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83"/><circle cx="12" cy="12" r="3"/></svg></button>
    <div class="divider"></div>
    <button class="tool-btn" id="undoBtn" title="Undo (Ctrl+Z)"><svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><path d="M3 7v6h6"/><path d="M3 13a9 9 0 1 0 2.5-6.5L3 7"/></svg></button>
    <button class="tool-btn" id="redoBtn" title="Redo (Ctrl+Shift+Z)"><svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><path d="M21 7v6h-6"/><path d="M21 13a9 9 0 1 1-2.5-6.5L21 7"/></svg></button>
    <div class="divider"></div>
    <button class="tool-btn" id="clearBtn" title="Clear Page Annotations"><svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2"/><path d="M19 6l-1 14a2 2 0 01-2 2H8a2 2 0 01-2-2L5 6"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg></button>
    <div class="divider"></div>
    <button class="tool-btn" id="fullscreenBtn" title="Fullscreen (F)"><svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 00-2 2v3"/><path d="M21 8V5a2 2 0 00-2-2h-3"/><path d="M3 16v3a2 2 0 002 2h3"/><path d="M16 21h3a2 2 0 002-2v-3"/></svg></button>
    <div class="divider pdf-controls" id="pdfDivider"></div>
    <div class="pdf-controls" id="pdfControls">
      <button class="pdf-nav-btn" id="prevPage" title="Previous Page"><svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"/></svg></button>
      <span class="pdf-page-info" id="pageInfo">1 / 1</span>
      <button class="pdf-nav-btn" id="nextPage" title="Next Page"><svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"/></svg></button>
      <button class="pdf-nav-btn pdf-close-btn" id="closePdf" title="Close PDF"><svg viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button>
    </div>
  </div>
  <div class="color-modal-overlay" id="colorModalOverlay">
    <div class="color-modal">
      <div class="color-modal-title">Choose Color</div>
      <div class="color-modal-grid" id="colorModalGrid"></div>
    </div>
  </div>
  <div class="filmstrip-overlay" id="filmstripOverlay">
    <div class="filmstrip-container" id="filmstripContainer"></div>
    <span class="filmstrip-hint">Tap a page to navigate • Tap outside to close</span>
  </div>
  <div class="loading-overlay" id="loadingOverlay"><div class="loading-spinner"></div></div>
  <div class="canvas-container no-pdf" id="canvasContainer">
    <div class="pdf-page-container" id="pdfPageContainer">
      <canvas id="pdf-canvas"></canvas>
      <svg id="drawing-svg" xmlns="http://www.w3.org/2000/svg"><g id="strokes-group"></g></svg>
    </div>
    <div class="eraser-cursor" id="eraserCursor"></div>
  </div>
  <script type="module">
    const pdfjsLib = await import('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.min.mjs');
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.worker.min.mjs';

    const dpr = window.devicePixelRatio || 1;
    const SEGMENT_MAX = 1200, BIG_ERASER_MULT = 6, TAP_THRESHOLD = 500;
    const sizes = Array.from({length: 63}, (_, i) => (i + 1) * 0.5);
    const colors = ['#1f2937','#6b7280','#ef4444','#f97316','#eab308','#84cc16','#22c55e','#14b8a6','#06b6d4','#3b82f6','#6366f1','#8b5cf6','#a855f7','#d946ef','#ec4899','#f43f5e','#78716c','#ffffff'];

    let tool = 'pen', width = 5.5, color = '#1f2937', sizeIdx = 10, drawing = false, path = null, points = [];
    let strokes = [], undoStack = [], pageAnnotations = {};
    let eraserEnd = false, lassoEnd = false, prevTool = 'pen', pressure = true, bigEraser = false, tapTimes = [], segLen = 0;
    let pdfDoc = null, currentPage = 1, totalPages = 0, pdfPageWidth = 0, pdfPageHeight = 0;
    let toolbarVisible = false, filmstripThumbnails = [];

    let lassoPath = null, lassoPoints = [], selectedStrokes = [], selectionBoxes = [], selectionHandles = [];
    let rotationHandle = null, rotationLine = null, duplicateHandle = null, duplicateIcon = null;
    let isDraggingSelection = false, isScalingSelection = false, isRotatingSelection = false;
    let activeHandle = null, dragStartX = 0, dragStartY = 0, selectionBounds = null, originalBounds = null, originalStrokePoints = [];
    let rotationCenterX = 0, rotationCenterY = 0, startAngle = 0, currentRotation = 0, previousRotation = 0;
    let scaleAnchorWorldX = 0, scaleAnchorWorldY = 0;

    // RAF optimization for drawing
    let needsRender = false;
    // Cache for getBoundingClientRect
    let cachedSvgRect = null;
    // Eraser throttling
    let lastEraseX = 0, lastEraseY = 0;
    // Point simplification epsilon (set to 0 to disable, 0.5-1.0 recommended)
    const SIMPLIFY_EPSILON = 0;
    // Max undo/redo stack size (older strokes become permanent)
    const MAX_UNDO_STACK = 10;
    const MAX_UNDO_STROKES = 10;

    const $ = id => document.getElementById(id);
    const svg = $('drawing-svg'), group = $('strokes-group'), container = $('canvasContainer');
    const cursor = $('eraserCursor'), sizeVal = $('sizeValue');
    const modal = $('colorModalOverlay'), grid = $('colorModalGrid');
    const pdfCanvas = $('pdf-canvas'), pdfCtx = pdfCanvas.getContext('2d');
    const loadingOverlay = $('loadingOverlay'), toolbar = $('toolbar'), pageInfo = $('pageInfo');
    const pdfInput = $('pdfInput'), pdfControls = $('pdfControls'), pdfDivider = $('pdfDivider');
    const menuBtn = $('menuBtn'), filmstripOverlay = $('filmstripOverlay'), filmstripContainer = $('filmstripContainer');
    const activePointers = new Map();
    let gestureStartDistance = 0, swipeStartX = 0, swipeStartY = 0;

    const getPdfScale = () => pdfDoc && pdfPageWidth > 0 ? pdfPageWidth / (container.getBoundingClientRect().width * dpr) : 1;
    const getEffectiveWidth = () => width * getPdfScale();
    const getEffectiveHandleSize = size => size * getPdfScale();
    const showToolbar = () => { toolbarVisible = true; toolbar.classList.remove('hidden'); };
    const hideToolbar = () => { toolbarVisible = false; toolbar.classList.add('hidden'); };
    const toggleToolbar = () => toolbarVisible ? hideToolbar() : showToolbar();

    const carousel = $('colorCarousel');
    let carouselVisible = false;
    let carouselRotation = 0; // Current rotation offset in radians
    const carouselItems = [];

    // Create full circle carousel items with even spacing
    const carouselRadius = 160;
    const totalArc = Math.PI * 2; // Full circle
    const arcStep = totalArc / colors.length; // Even spacing around the circle

    const updateCarouselPositions = () => {
      carouselItems.forEach((item, i) => {
        const baseAngle = -Math.PI / 2 + i * arcStep; // Start from top
        const angle = baseAngle + carouselRotation;
        const x = Math.cos(angle) * carouselRadius;
        const y = Math.sin(angle) * carouselRadius;
        item.style.left = (x - 20) + 'px';
        item.style.bottom = (-y - 20) + 'px';
        // Fade out items that are behind/below
        const normalizedAngle = ((angle % totalArc) + totalArc) % totalArc;
        const opacity = (normalizedAngle > Math.PI / 2 && normalizedAngle < Math.PI * 1.5) ? 0.3 : 1;
        item.style.opacity = carouselVisible ? opacity : 0;
      });
    };

    colors.forEach((c, i) => {
      const isWhite = c === '#ffffff';
      // Grid modal colors (keeping for stepper click)
      const b = document.createElement('button');
      b.className = 'color-modal-btn' + (c === color ? ' selected' : '') + (isWhite ? ' white-color' : '');
      b.style.background = c;
      b.dataset.color = c;
      b.onclick = () => {
        color = c;
        sizeVal.style.color = c === '#ffffff' ? '#1f2937' : c;
        grid.querySelectorAll('.color-modal-btn').forEach(x => x.classList.toggle('selected', x.dataset.color === c));
        carousel.querySelectorAll('.color-carousel-item').forEach(x => x.classList.toggle('selected', x.dataset.color === c));
        modal.classList.remove('visible');
      };
      grid.appendChild(b);

      // Carousel colors
      const item = document.createElement('div');
      item.className = 'color-carousel-item' + (c === color ? ' selected' : '') + (isWhite ? ' white-color' : '');
      item.style.background = c;
      item.dataset.color = c;
      item.onclick = e => {
        e.stopPropagation();
        color = c;
        sizeVal.style.color = c === '#ffffff' ? '#1f2937' : c;
        grid.querySelectorAll('.color-modal-btn').forEach(x => x.classList.toggle('selected', x.dataset.color === c));
        carousel.querySelectorAll('.color-carousel-item').forEach(x => x.classList.toggle('selected', x.dataset.color === c));
        hideCarousel();
      };
      carousel.appendChild(item);
      carouselItems.push(item);
    });

    // Touch/drag spin handling
    let spinVelocity = 0;
    let spinAnimationId = null;
    let isDraggingCarousel = false;
    let lastDragX = 0, lastDragY = 0;
    let lastDragTime = 0;

    const carouselOriginX = 30; // carousel position from left
    const carouselOriginY = window.innerHeight - 30; // carousel position from top

    const handleCarouselDown = e => {
      if (!carouselVisible) return;
      isDraggingCarousel = true;
      lastDragX = e.clientX;
      lastDragY = e.clientY;
      lastDragTime = Date.now();
      spinVelocity = 0;
      if (spinAnimationId) { cancelAnimationFrame(spinAnimationId); spinAnimationId = null; }
      e.stopPropagation();
    };

    const handleCarouselMove = e => {
      if (!isDraggingCarousel || !carouselVisible) return;
      e.preventDefault();
      e.stopPropagation();

      const now = Date.now();
      const dt = Math.max(1, now - lastDragTime);

      // Calculate angle change based on drag around the origin point
      const prevAngle = Math.atan2(carouselOriginY - lastDragY, lastDragX - carouselOriginX);
      const currAngle = Math.atan2(carouselOriginY - e.clientY, e.clientX - carouselOriginX);
      let deltaAngle = currAngle - prevAngle;

      // Handle angle wrap-around
      if (deltaAngle > Math.PI) deltaAngle -= Math.PI * 2;
      if (deltaAngle < -Math.PI) deltaAngle += Math.PI * 2;

      carouselRotation -= deltaAngle;
      spinVelocity = -deltaAngle / dt * 16; // Normalize to ~60fps

      lastDragX = e.clientX;
      lastDragY = e.clientY;
      lastDragTime = now;

      updateCarouselPositions();
    };

    const handleCarouselUp = e => {
      if (!isDraggingCarousel) return;
      isDraggingCarousel = false;
      // Start momentum animation if there's velocity
      if (Math.abs(spinVelocity) > 0.001 && !spinAnimationId) animateSpin();
    };

    const animateSpin = () => {
      carouselRotation += spinVelocity;
      spinVelocity *= 0.92; // Friction
      updateCarouselPositions();
      if (Math.abs(spinVelocity) > 0.001) {
        spinAnimationId = requestAnimationFrame(animateSpin);
      } else {
        spinVelocity = 0;
        spinAnimationId = null;
      }
    };

    const hitarea = $('carouselHitarea');
    carousel.addEventListener('pointerdown', handleCarouselDown);
    hitarea.addEventListener('pointerdown', handleCarouselDown);
    document.addEventListener('pointermove', handleCarouselMove);
    document.addEventListener('pointerup', handleCarouselUp);
    document.addEventListener('pointercancel', handleCarouselUp);

    const showCarousel = () => {
      carouselVisible = true;
      carousel.classList.add('visible');
      updateCarouselPositions();
    };
    const hideCarousel = () => {
      carouselVisible = false;
      carousel.classList.remove('visible');
      if (spinAnimationId) { cancelAnimationFrame(spinAnimationId); spinAnimationId = null; }
      spinVelocity = 0;
    };
    const toggleCarousel = () => carouselVisible ? hideCarousel() : showCarousel();

    // Initialize positions
    updateCarouselPositions();

    sizeVal.onclick = () => modal.classList.add('visible');
    modal.onclick = e => { if (e.target === modal) modal.classList.remove('visible'); };

    const setTool = (t, preserveSelection = false) => {
      tool = t;
      $('penTool').classList.toggle('active', t === 'pen');
      $('eraserTool').classList.toggle('active', t === 'eraser');
      $('lassoTool').classList.toggle('active', t === 'lasso');
      container.classList.toggle('eraser-mode', t === 'eraser');
      container.classList.toggle('lasso-mode', t === 'lasso');
      if (t !== 'lasso' && !preserveSelection) clearSelection();
      updateCursor();
    };

    const updateCursor = () => {
      const s = width * 3 * (bigEraser ? BIG_ERASER_MULT : 1);
      cursor.style.width = cursor.style.height = s + 'px';
      cursor.classList.toggle('big-eraser', bigEraser);
    };

    const checkTap = () => {
      const n = Date.now();
      tapTimes.push(n);
      tapTimes = tapTimes.filter(t => n - t < TAP_THRESHOLD);
      if (tapTimes.length >= 3) { bigEraser = true; tapTimes = []; updateCursor(); }
    };

    const resetBig = () => { if (bigEraser) { bigEraser = false; tapTimes = []; updateCursor(); } };

    const removeDuplicateUI = () => {
      if (duplicateHandle) { duplicateHandle.remove(); duplicateHandle = null; }
      if (duplicateIcon) { duplicateIcon.remove(); duplicateIcon = null; }
    };

    const removeRotationUI = () => {
      if (rotationHandle) { rotationHandle.remove(); rotationHandle = null; }
      if (rotationLine) { rotationLine.remove(); rotationLine = null; }
    };

    const clearSelection = () => {
      selectedStrokes = [];
      selectionBoxes.forEach(box => box.remove());
      selectionBoxes = [];
      selectionHandles.forEach(h => h.remove());
      selectionHandles = [];
      removeRotationUI();
      removeDuplicateUI();
      if (lassoPath) { lassoPath.remove(); lassoPath = null; }
      lassoPoints = [];
      selectionBounds = originalBounds = null;
      originalStrokePoints = [];
      currentRotation = previousRotation = 0;
    };

    const pointInPolygon = (x, y, polygon) => {
      let inside = false;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i].x, yi = polygon[i].y, xj = polygon[j].x, yj = polygon[j].y;
        if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) inside = !inside;
      }
      return inside;
    };

    const createSelectionHandles = () => {
      selectionHandles.forEach(h => h.remove());
      selectionHandles = [];
      removeRotationUI();
      removeDuplicateUI();
      if (!selectionBounds) return;

      const handleSize = getEffectiveHandleSize(30), rotationOffset = getEffectiveHandleSize(50);
      const corners = [
        { x: selectionBounds.x, y: selectionBounds.y },
        { x: selectionBounds.x + selectionBounds.width, y: selectionBounds.y },
        { x: selectionBounds.x, y: selectionBounds.y + selectionBounds.height },
        { x: selectionBounds.x + selectionBounds.width, y: selectionBounds.y + selectionBounds.height }
      ];

      corners.forEach(corner => {
        const handle = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        handle.classList.add('selection-handle');
        handle.setAttribute('x', corner.x - handleSize / 2);
        handle.setAttribute('y', corner.y - handleSize / 2);
        handle.setAttribute('width', handleSize);
        handle.setAttribute('height', handleSize);
        group.appendChild(handle);
        selectionHandles.push(handle);
      });

      const centerX = selectionBounds.x + selectionBounds.width / 2, topY = selectionBounds.y;
      rotationLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      rotationLine.classList.add('rotation-line');
      rotationLine.setAttribute('x1', centerX);
      rotationLine.setAttribute('y1', topY);
      rotationLine.setAttribute('x2', centerX);
      rotationLine.setAttribute('y2', topY - rotationOffset);
      group.appendChild(rotationLine);

      rotationHandle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      rotationHandle.classList.add('rotation-handle');
      rotationHandle.setAttribute('cx', centerX);
      rotationHandle.setAttribute('cy', topY - rotationOffset);
      rotationHandle.setAttribute('r', getEffectiveHandleSize(20));
      group.appendChild(rotationHandle);

      if (currentRotation === 0) {
        const bottomY = selectionBounds.y + selectionBounds.height;
        const duplicateOffset = getEffectiveHandleSize(50), duplicateSize = getEffectiveHandleSize(36);
        duplicateHandle = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        duplicateHandle.classList.add('duplicate-handle');
        duplicateHandle.setAttribute('x', centerX - duplicateSize / 2);
        duplicateHandle.setAttribute('y', bottomY + duplicateOffset - duplicateSize / 2);
        duplicateHandle.setAttribute('width', duplicateSize);
        duplicateHandle.setAttribute('height', duplicateSize);
        duplicateHandle.setAttribute('rx', getEffectiveHandleSize(6));
        group.appendChild(duplicateHandle);

        const iconSize = getEffectiveHandleSize(14), iconOffset = getEffectiveHandleSize(4);
        duplicateIcon = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        duplicateIcon.classList.add('duplicate-icon');
        duplicateIcon.setAttribute('pointer-events', 'none');
        duplicateIcon.innerHTML = `
          <rect x="${centerX - iconSize/2 + iconOffset/2}" y="${bottomY + duplicateOffset - iconSize/2 - iconOffset/2}" width="${iconSize}" height="${iconSize}" rx="${getEffectiveHandleSize(2)}" fill="none" stroke="var(--active)" stroke-width="${getEffectiveHandleSize(1.5)}"/>
          <rect x="${centerX - iconSize/2 - iconOffset/2}" y="${bottomY + duplicateOffset - iconSize/2 + iconOffset/2}" width="${iconSize}" height="${iconSize}" rx="${getEffectiveHandleSize(2)}" fill="#fff" stroke="var(--active)" stroke-width="${getEffectiveHandleSize(1.5)}"/>
        `;
        group.appendChild(duplicateIcon);
      }
    };

    const updateSelectionUI = (preserveRotation = false) => {
      if (!selectionBounds || selectionBoxes.length === 0) return;

      selectionBoxes[0].setAttribute('x', selectionBounds.x);
      selectionBoxes[0].setAttribute('y', selectionBounds.y);
      selectionBoxes[0].setAttribute('width', selectionBounds.width);
      selectionBoxes[0].setAttribute('height', selectionBounds.height);

      const handleSize = getEffectiveHandleSize(30), rotationOffset = getEffectiveHandleSize(50);
      const corners = [
        { x: selectionBounds.x, y: selectionBounds.y },
        { x: selectionBounds.x + selectionBounds.width, y: selectionBounds.y },
        { x: selectionBounds.x, y: selectionBounds.y + selectionBounds.height },
        { x: selectionBounds.x + selectionBounds.width, y: selectionBounds.y + selectionBounds.height }
      ];

      selectionHandles.forEach((handle, i) => {
        handle.setAttribute('x', corners[i].x - handleSize / 2);
        handle.setAttribute('y', corners[i].y - handleSize / 2);
        handle.setAttribute('width', handleSize);
        handle.setAttribute('height', handleSize);
      });

      const centerX = selectionBounds.x + selectionBounds.width / 2;
      const topY = selectionBounds.y, bottomY = selectionBounds.y + selectionBounds.height;

      if (rotationHandle && rotationLine) {
        rotationLine.setAttribute('x1', centerX);
        rotationLine.setAttribute('y1', topY);
        rotationLine.setAttribute('x2', centerX);
        rotationLine.setAttribute('y2', topY - rotationOffset);
        rotationHandle.setAttribute('cx', centerX);
        rotationHandle.setAttribute('cy', topY - rotationOffset);
        rotationHandle.setAttribute('r', getEffectiveHandleSize(20));
      }

      if (duplicateHandle && duplicateIcon) {
        const duplicateOffset = getEffectiveHandleSize(50), duplicateSize = getEffectiveHandleSize(36);
        duplicateHandle.setAttribute('x', centerX - duplicateSize / 2);
        duplicateHandle.setAttribute('y', bottomY + duplicateOffset - duplicateSize / 2);
        duplicateHandle.setAttribute('width', duplicateSize);
        duplicateHandle.setAttribute('height', duplicateSize);
        duplicateHandle.setAttribute('rx', getEffectiveHandleSize(6));

        const iconSize = getEffectiveHandleSize(14), iconOffset = getEffectiveHandleSize(4);
        duplicateIcon.innerHTML = `
          <rect x="${centerX - iconSize/2 + iconOffset/2}" y="${bottomY + duplicateOffset - iconSize/2 - iconOffset/2}" width="${iconSize}" height="${iconSize}" rx="${getEffectiveHandleSize(2)}" fill="none" stroke="var(--active)" stroke-width="${getEffectiveHandleSize(1.5)}"/>
          <rect x="${centerX - iconSize/2 - iconOffset/2}" y="${bottomY + duplicateOffset - iconSize/2 + iconOffset/2}" width="${iconSize}" height="${iconSize}" rx="${getEffectiveHandleSize(2)}" fill="#fff" stroke="var(--active)" stroke-width="${getEffectiveHandleSize(1.5)}"/>
        `;
      }

      if (preserveRotation && currentRotation !== 0) {
        const cx = selectionBounds.x + selectionBounds.width / 2, cy = selectionBounds.y + selectionBounds.height / 2;
        const rotateTransform = `rotate(${currentRotation * (180 / Math.PI)}, ${cx}, ${cy})`;
        selectionBoxes[0]?.setAttribute('transform', rotateTransform);
        selectionHandles.forEach(h => h.setAttribute('transform', rotateTransform));
        rotationHandle?.setAttribute('transform', rotateTransform);
        rotationLine?.setAttribute('transform', rotateTransform);
        duplicateHandle?.setAttribute('transform', rotateTransform);
        duplicateIcon?.setAttribute('transform', rotateTransform);
      }
    };

    const selectStrokesInLasso = () => {
      selectionBoxes.forEach(box => box.remove());
      selectionBoxes = [];
      selectionHandles.forEach(h => h.remove());
      selectionHandles = [];
      selectedStrokes = [];
      if (lassoPoints.length < 3) return;

      strokes.forEach(s => {
        if (s.points.some(p => pointInPolygon(p.x, p.y, lassoPoints))) selectedStrokes.push(s);
      });

      if (selectedStrokes.length > 0) {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        lassoPoints.forEach(p => { minX = Math.min(minX, p.x); minY = Math.min(minY, p.y); maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y); });
        selectionBounds = { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.classList.add('selection-box');
        rect.setAttribute('x', minX);
        rect.setAttribute('y', minY);
        rect.setAttribute('width', maxX - minX);
        rect.setAttribute('height', maxY - minY);
        rect.setAttribute('rx', 3);
        group.appendChild(rect);
        selectionBoxes.push(rect);
        createSelectionHandles();
      } else {
        selectionBounds = null;
      }
    };

    const deleteSelectedStrokes = () => {
      if (selectedStrokes.length === 0) return;
      selectedStrokes.forEach(s => {
        s.element.remove();
        const idx = strokes.indexOf(s);
        if (idx > -1) pushUndo(strokes.splice(idx, 1)[0]);
      });
      selectedStrokes = [];
      selectionBoxes.forEach(box => box.remove());
      selectionBoxes = [];
      selectionHandles.forEach(h => h.remove());
      selectionHandles = [];
      removeRotationUI();
      removeDuplicateUI();
      selectionBounds = null;
      currentRotation = previousRotation = 0;
      savePageAnnotations();
    };

    const duplicateSelectedStrokes = () => {
      if (selectedStrokes.length === 0) return;
      const offset = 20 * getPdfScale();
      const newStrokes = [];

      selectedStrokes.forEach(s => {
        const el = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        el.classList.add('stroke-path');
        el.setAttribute('fill', s.color);
        const newPoints = s.points.map(p => ({ ...p, x: p.x + offset, y: p.y + offset }));
        el.setAttribute('d', buildPath(newPoints, s.width));
        group.appendChild(el);
        const newStroke = { element: el, points: newPoints, color: s.color, width: s.width };
        addStroke(newStroke);
        newStrokes.push(newStroke);
      });

      selectionBoxes.forEach(box => box.remove());
      selectionBoxes = [];
      selectionHandles.forEach(h => h.remove());
      selectionHandles = [];
      removeRotationUI();
      removeDuplicateUI();

      selectedStrokes = newStrokes;
      currentRotation = previousRotation = 0;

      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      newStrokes.forEach(s => s.points.forEach(p => { minX = Math.min(minX, p.x); minY = Math.min(minY, p.y); maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y); }));
      selectionBounds = { x: minX, y: minY, width: maxX - minX, height: maxY - minY };

      const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      rect.classList.add('selection-box');
      rect.setAttribute('x', minX);
      rect.setAttribute('y', minY);
      rect.setAttribute('width', maxX - minX);
      rect.setAttribute('height', maxY - minY);
      rect.setAttribute('rx', 3);
      group.appendChild(rect);
      selectionBoxes.push(rect);
      createSelectionHandles();
      savePageAnnotations();
    };

    const transformPointForHitTest = (x, y) => {
      if (currentRotation === 0) return { x, y };
      const cx = selectionBounds.x + selectionBounds.width / 2, cy = selectionBounds.y + selectionBounds.height / 2;
      const cos = Math.cos(-currentRotation), sin = Math.sin(-currentRotation);
      const dx = x - cx, dy = y - cy;
      return { x: cx + dx * cos - dy * sin, y: cy + dx * sin + dy * cos };
    };

    const isInsideSelectionBox = (x, y) => {
      if (!selectionBounds || selectedStrokes.length === 0) return false;
      const p = transformPointForHitTest(x, y);
      return p.x >= selectionBounds.x && p.x <= selectionBounds.x + selectionBounds.width && p.y >= selectionBounds.y && p.y <= selectionBounds.y + selectionBounds.height;
    };

    const getHandleAtPoint = (x, y) => {
      if (!selectionBounds || selectedStrokes.length === 0) return null;
      const p = transformPointForHitTest(x, y);
      const handleHitSize = getEffectiveHandleSize(20);
      const corners = [
        { id: 'tl', x: selectionBounds.x, y: selectionBounds.y },
        { id: 'tr', x: selectionBounds.x + selectionBounds.width, y: selectionBounds.y },
        { id: 'bl', x: selectionBounds.x, y: selectionBounds.y + selectionBounds.height },
        { id: 'br', x: selectionBounds.x + selectionBounds.width, y: selectionBounds.y + selectionBounds.height }
      ];
      for (const corner of corners) {
        if (Math.abs(p.x - corner.x) <= handleHitSize && Math.abs(p.y - corner.y) <= handleHitSize) return corner.id;
      }
      return null;
    };

    const moveSelection = (dx, dy) => {
      selectedStrokes.forEach(s => {
        s.points = s.points.map(p => ({ ...p, x: p.x + dx, y: p.y + dy }));
        s.element.setAttribute('d', buildPath(s.points, s.width));
      });
      if (selectionBounds) {
        selectionBounds.x += dx;
        selectionBounds.y += dy;
        updateSelectionUI(true);
      }
    };

    const scaleSelection = (newX, newY) => {
      if (!originalBounds || !activeHandle) return;
      const origCx = originalBounds.x + originalBounds.width / 2, origCy = originalBounds.y + originalBounds.height / 2;
      const cos = Math.cos(currentRotation), sin = Math.sin(currentRotation);

      let handleLocalX, handleLocalY;
      if (activeHandle === 'tl') { handleLocalX = originalBounds.x; handleLocalY = originalBounds.y; }
      else if (activeHandle === 'tr') { handleLocalX = originalBounds.x + originalBounds.width; handleLocalY = originalBounds.y; }
      else if (activeHandle === 'bl') { handleLocalX = originalBounds.x; handleLocalY = originalBounds.y + originalBounds.height; }
      else { handleLocalX = originalBounds.x + originalBounds.width; handleLocalY = originalBounds.y + originalBounds.height; }

      const dxH = handleLocalX - origCx, dyH = handleLocalY - origCy;
      const handleWorldX = origCx + dxH * cos - dyH * sin, handleWorldY = origCy + dxH * sin + dyH * cos;
      const origDist = Math.hypot(handleWorldX - scaleAnchorWorldX, handleWorldY - scaleAnchorWorldY);
      const newDist = Math.hypot(newX - scaleAnchorWorldX, newY - scaleAnchorWorldY);
      const minScale = 20 / Math.max(originalBounds.width, originalBounds.height);
      const scale = Math.max(minScale, origDist > 0 ? newDist / origDist : 1);

      selectedStrokes.forEach((s, i) => {
        const origPoints = originalStrokePoints[i];
        s.points = origPoints.map(pt => ({ ...pt, x: scaleAnchorWorldX + (pt.x - scaleAnchorWorldX) * scale, y: scaleAnchorWorldY + (pt.y - scaleAnchorWorldY) * scale }));
        s.element.setAttribute('d', buildPath(s.points, s.width));
      });

      const scaledWidth = originalBounds.width * scale, scaledHeight = originalBounds.height * scale;
      const newCx = scaleAnchorWorldX + (origCx - scaleAnchorWorldX) * scale, newCy = scaleAnchorWorldY + (origCy - scaleAnchorWorldY) * scale;
      selectionBounds.x = newCx - scaledWidth / 2;
      selectionBounds.y = newCy - scaledHeight / 2;
      selectionBounds.width = scaledWidth;
      selectionBounds.height = scaledHeight;
      updateSelectionUI(true);
    };

    const isOnRotationHandle = (x, y) => {
      if (!selectionBounds || selectedStrokes.length === 0 || !rotationHandle) return false;
      const p = transformPointForHitTest(x, y);
      const centerX = selectionBounds.x + selectionBounds.width / 2;
      const handleY = selectionBounds.y - getEffectiveHandleSize(50);
      return Math.hypot(p.x - centerX, p.y - handleY) <= getEffectiveHandleSize(25);
    };

    const isOnDuplicateHandle = (x, y) => {
      if (!selectionBounds || selectedStrokes.length === 0 || !duplicateHandle) return false;
      const p = transformPointForHitTest(x, y);
      const centerX = selectionBounds.x + selectionBounds.width / 2;
      const handleY = selectionBounds.y + selectionBounds.height + getEffectiveHandleSize(50);
      const hitSize = getEffectiveHandleSize(22);
      return Math.abs(p.x - centerX) <= hitSize && Math.abs(p.y - handleY) <= hitSize;
    };

    const rotateSelection = (x, y) => {
      if (!originalBounds) return;
      const angle = Math.atan2(y - rotationCenterY, x - rotationCenterX);
      const deltaAngle = angle - startAngle;
      const totalRotation = previousRotation + deltaAngle;
      const cos = Math.cos(deltaAngle), sin = Math.sin(deltaAngle);

      selectedStrokes.forEach((s, i) => {
        const origPoints = originalStrokePoints[i];
        s.points = origPoints.map(p => {
          const dx = p.x - rotationCenterX, dy = p.y - rotationCenterY;
          return { ...p, x: rotationCenterX + dx * cos - dy * sin, y: rotationCenterY + dx * sin + dy * cos };
        });
        s.element.setAttribute('d', buildPath(s.points, s.width));
      });

      const rotateTransform = `rotate(${totalRotation * (180 / Math.PI)}, ${rotationCenterX}, ${rotationCenterY})`;
      selectionBoxes[0]?.setAttribute('transform', rotateTransform);
      selectionHandles.forEach(h => h.setAttribute('transform', rotateTransform));
      rotationHandle?.setAttribute('transform', rotateTransform);
      rotationLine?.setAttribute('transform', rotateTransform);
      currentRotation = totalRotation;
    };

    const savePageAnnotations = () => {
      if (pdfDoc) pageAnnotations[currentPage] = { strokes: strokes.map(s => ({ ...s })), undoStack: undoStack.map(s => ({ ...s })) };
    };

    const loadPageAnnotations = () => {
      group.innerHTML = '';
      const data = pageAnnotations[currentPage];
      if (data) {
        strokes = data.strokes.map(s => {
          const el = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          el.classList.add('stroke-path');
          el.setAttribute('fill', s.color);
          el.setAttribute('d', buildPath(s.points, s.width));
          group.appendChild(el);
          return { ...s, element: el };
        });
        undoStack = data.undoStack.map(s => {
          const el = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          el.classList.add('stroke-path');
          el.setAttribute('fill', s.color);
          el.setAttribute('d', buildPath(s.points, s.width));
          return { ...s, element: el };
        });
        undoableCount = Math.min(strokes.length, MAX_UNDO_STROKES);
      } else {
        strokes = [];
        undoStack = [];
        undoableCount = 0;
      }
    };

    const pushUndo = (...items) => {
      undoStack.push(...items);
      while (undoStack.length > MAX_UNDO_STACK) undoStack.shift();
    };
    // Track how many recent strokes can be undone
    let undoableCount = 0;
    const addStroke = (stroke) => {
      strokes.push(stroke);
      undoableCount = Math.min(undoableCount + 1, MAX_UNDO_STROKES);
    };
    const undo = () => {
      if (strokes.length && undoableCount > 0) {
        const s = strokes.pop();
        undoableCount--;
        pushUndo(s);
        s.element.remove();
        savePageAnnotations();
      }
    };
    const redo = () => {
      if (undoStack.length) {
        const s = undoStack.pop();
        group.appendChild(s.element);
        addStroke(s);
        savePageAnnotations();
      }
    };
    const isEraser = e => e.button === 5 || (e.buttons & 32) !== 0;
    const isLassoButton = e => e.button === 2 || (e.buttons & 2) !== 0;

    const getData = e => {
      const r = cachedSvgRect || svg.getBoundingClientRect();
      if (pdfDoc && pdfPageWidth > 0) {
        return { x: ((e.clientX - r.left) / r.width) * pdfPageWidth, y: ((e.clientY - r.top) / r.height) * pdfPageHeight, pressure: e.pressure ?? 0.5 };
      }
      return { x: (e.clientX - r.left) * dpr, y: (e.clientY - r.top) * dpr, pressure: e.pressure ?? 0.5 };
    };

    // Ramer-Douglas-Peucker point simplification
    const perpendicularDist = (p, a, b) => {
      const dx = b.x - a.x, dy = b.y - a.y;
      const len = Math.hypot(dx, dy);
      if (len === 0) return Math.hypot(p.x - a.x, p.y - a.y);
      return Math.abs(dy * p.x - dx * p.y + b.x * a.y - b.y * a.x) / len;
    };

    const simplifyPoints = (pts, epsilon) => {
      if (epsilon <= 0 || pts.length <= 2) return pts;
      let maxDist = 0, maxIdx = 0;
      const first = pts[0], last = pts[pts.length - 1];
      for (let i = 1; i < pts.length - 1; i++) {
        const dist = perpendicularDist(pts[i], first, last);
        if (dist > maxDist) { maxDist = dist; maxIdx = i; }
      }
      if (maxDist > epsilon) {
        const left = simplifyPoints(pts.slice(0, maxIdx + 1), epsilon);
        const right = simplifyPoints(pts.slice(maxIdx), epsilon);
        return [...left.slice(0, -1), ...right];
      }
      return [first, last];
    };

    function buildPath(pts, w) {
      if (pts.length < 2) {
        const p = pts[0], r = (w * p.pressure * 1.5) / 2;
        return `M${p.x-r},${p.y}a${r},${r} 0 1,0 ${r*2},0a${r},${r} 0 1,0 ${-r*2},0`;
      }
      const L = [], R = [];
      for (let i = 0; i < pts.length; i++) {
        const p = pts[i], pr = pressure ? Math.max(0.25, Math.pow(p.pressure, 0.75)) : 0.7, hw = (w * pr * 1.5) / 2;
        let dx, dy;
        if (i === 0) { dx = pts[1].x - p.x; dy = pts[1].y - p.y; }
        else if (i === pts.length - 1) { dx = p.x - pts[i-1].x; dy = p.y - pts[i-1].y; }
        else { dx = pts[i+1].x - pts[i-1].x; dy = pts[i+1].y - pts[i-1].y; }
        const len = Math.sqrt(dx*dx + dy*dy) || 1, nx = -dy/len, ny = dx/len;
        L.push({ x: p.x + nx*hw, y: p.y + ny*hw });
        R.push({ x: p.x - nx*hw, y: p.y - ny*hw });
      }
      let d = `M${L[0].x},${L[0].y}`;
      for (let i = 1; i < L.length; i++) d += `Q${L[i-1].x},${L[i-1].y},${(L[i-1].x+L[i].x)/2},${(L[i-1].y+L[i].y)/2}`;
      const ll = L[L.length-1], lr = R[R.length-1];
      d += `L${(ll.x+lr.x)/2},${(ll.y+lr.y)/2}`;
      for (let i = R.length-2; i >= 0; i--) d += `Q${R[i+1].x},${R[i+1].y},${(R[i+1].x+R[i].x)/2},${(R[i+1].y+R[i].y)/2}`;
      d += `Q${R[0].x},${R[0].y},${L[0].x},${L[0].y}Z`;
      return d;
    }

    const newPath = () => {
      path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.classList.add('stroke-path');
      path.setAttribute('fill', color);
      path.setAttribute('d', buildPath(points, getEffectiveWidth()));
      group.appendChild(path);
    };

    const finalize = () => { if (path && points.length > 1) { addStroke({ element: path, points: [...points], color, width: getEffectiveWidth() }); savePageAnnotations(); } };
    const setCursor = e => { cursor.style.left = e.clientX + 'px'; cursor.style.top = e.clientY + 'px'; };

    function start(e) {
      if (e.pointerType === 'touch') return;
      cachedSvgRect = svg.getBoundingClientRect();
      if (isEraser(e)) {
        eraserEnd = true; lassoEnd = false; prevTool = tool;
        if (tool !== 'eraser') setTool('eraser');
        checkTap(); setCursor(e);
      } else if (isLassoButton(e)) {
        lassoEnd = true; eraserEnd = false; prevTool = tool;
        if (tool !== 'lasso') setTool('lasso');
      } else {
        if (e.button && e.button !== 0) return;
        eraserEnd = lassoEnd = false;
      }
      e.preventDefault();
      const d = getData(e);

      if (tool === 'lasso' && isOnRotationHandle(d.x, d.y)) {
        isRotatingSelection = true;
        originalBounds = { ...selectionBounds };
        originalStrokePoints = selectedStrokes.map(s => s.points.map(p => ({ ...p })));
        rotationCenterX = selectionBounds.x + selectionBounds.width / 2;
        rotationCenterY = selectionBounds.y + selectionBounds.height / 2;
        startAngle = Math.atan2(d.y - rotationCenterY, d.x - rotationCenterX);
        previousRotation = currentRotation;
        removeDuplicateUI();
        drawing = false;
        return;
      }

      if (tool === 'lasso' && isOnDuplicateHandle(d.x, d.y)) { duplicateSelectedStrokes(); drawing = false; return; }

      if (tool === 'lasso') {
        const handle = getHandleAtPoint(d.x, d.y);
        if (handle) {
          isScalingSelection = true;
          activeHandle = handle;
          originalBounds = { ...selectionBounds };
          originalStrokePoints = selectedStrokes.map(s => s.points.map(p => ({ ...p })));
          const cx = selectionBounds.x + selectionBounds.width / 2, cy = selectionBounds.y + selectionBounds.height / 2;
          let anchorLocalX, anchorLocalY;
          if (handle === 'tl') { anchorLocalX = selectionBounds.x + selectionBounds.width; anchorLocalY = selectionBounds.y + selectionBounds.height; }
          else if (handle === 'tr') { anchorLocalX = selectionBounds.x; anchorLocalY = selectionBounds.y + selectionBounds.height; }
          else if (handle === 'bl') { anchorLocalX = selectionBounds.x + selectionBounds.width; anchorLocalY = selectionBounds.y; }
          else { anchorLocalX = selectionBounds.x; anchorLocalY = selectionBounds.y; }
          const cos = Math.cos(currentRotation), sin = Math.sin(currentRotation);
          const dxA = anchorLocalX - cx, dyA = anchorLocalY - cy;
          scaleAnchorWorldX = cx + dxA * cos - dyA * sin;
          scaleAnchorWorldY = cy + dxA * sin + dyA * cos;
          drawing = false;
          return;
        }
      }

      if (tool === 'lasso' && isInsideSelectionBox(d.x, d.y)) {
        isDraggingSelection = true;
        dragStartX = d.x; dragStartY = d.y;
        drawing = false;
        return;
      }

      drawing = true;
      points = [];
      segLen = 0;
      undoStack = [];
      points.push(d);
      if (tool === 'pen') newPath();
      if (tool === 'eraser') setCursor(e);
      if (tool === 'lasso') {
        if (selectedStrokes.length > 0) { clearSelection(); setTool('pen'); drawing = false; return; }
        clearSelection();
        lassoPoints = [{ x: d.x, y: d.y }];
        lassoPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        lassoPath.classList.add('lasso-path');
        lassoPath.setAttribute('d', `M${d.x},${d.y}`);
        group.appendChild(lassoPath);
      }
    }

    function move(e) {
      if (e.pointerType === 'touch') return;
      if (isRotatingSelection) { e.preventDefault(); rotateSelection(getData(e).x, getData(e).y); return; }
      if (isScalingSelection) { e.preventDefault(); const d = getData(e); scaleSelection(d.x, d.y); return; }
      if (isDraggingSelection) { e.preventDefault(); const d = getData(e); moveSelection(d.x - dragStartX, d.y - dragStartY); dragStartX = d.x; dragStartY = d.y; return; }
      if (!drawing) return;
      e.preventDefault();
      const d = getData(e);
      if (tool === 'eraser') { setCursor(e); erase(d.x, d.y); return; }
      if (tool === 'lasso') {
        const last = lassoPoints[lassoPoints.length - 1];
        if (Math.hypot(d.x - last.x, d.y - last.y) < 3) return;
        lassoPoints.push({ x: d.x, y: d.y });
        let pathD = `M${lassoPoints[0].x},${lassoPoints[0].y}`;
        for (let i = 1; i < lassoPoints.length; i++) pathD += `L${lassoPoints[i].x},${lassoPoints[i].y}`;
        lassoPath.setAttribute('d', pathD);
        return;
      }
      const last = points[points.length - 1], dist = Math.hypot(d.x - last.x, d.y - last.y);
      if (dist < 2) return;
      segLen += dist;
      points.push(d);
      needsRender = true;
      if (segLen >= SEGMENT_MAX) {
        path.setAttribute('d', buildPath(points, getEffectiveWidth()));
        finalize();
        points = points.slice(-2);
        segLen = 0;
        newPath();
        needsRender = false;
      }
    }

    function stop(e) {
      if (e && e.pointerType === 'touch') return;
      cachedSvgRect = null;
      if (isRotatingSelection) { isRotatingSelection = false; originalBounds = null; originalStrokePoints = []; savePageAnnotations(); return; }
      if (isScalingSelection) { isScalingSelection = false; activeHandle = null; originalBounds = null; originalStrokePoints = []; savePageAnnotations(); return; }
      if (isDraggingSelection) { isDraggingSelection = false; savePageAnnotations(); return; }
      if (!drawing) return;
      drawing = false;
      needsRender = false;
      if (tool === 'pen' && path) {
        const simplified = simplifyPoints(points, SIMPLIFY_EPSILON);
        path.setAttribute('d', buildPath(simplified, getEffectiveWidth()));
        addStroke({ element: path, points: simplified, color, width: getEffectiveWidth() });
        savePageAnnotations();
        path = null;
      }
      if (tool === 'lasso' && lassoPath && lassoPoints.length >= 3) { lassoPath.remove(); lassoPath = null; selectStrokesInLasso(); }
      else if (tool === 'lasso') clearSelection();
      points = [];
      if (eraserEnd) { eraserEnd = false; resetBig(); if (prevTool !== 'eraser') setTool(prevTool); }
      if (lassoEnd) { lassoEnd = false; if (selectedStrokes.length === 0 && prevTool !== 'lasso') setTool(prevTool); }
    }

    function erase(x, y) {
      // Skip if cursor hasn't moved enough (throttle hit-testing)
      if (Math.hypot(x - lastEraseX, y - lastEraseY) < 5) return;
      lastEraseX = x;
      lastEraseY = y;

      const r = getEffectiveWidth() * 1.5 * (bigEraser ? BIG_ERASER_MULT : 1) * dpr;
      let erased = false;
      for (let i = strokes.length - 1; i >= 0; i--) {
        const s = strokes[i], b = s.element.getBBox();
        if (x < b.x-r || x > b.x+b.width+r || y < b.y-r || y > b.y+b.height+r) continue;
        for (const p of s.points) {
          if (Math.hypot(x-p.x, y-p.y) < r + s.width) { s.element.remove(); pushUndo(strokes.splice(i,1)[0]); erased = true; break; }
        }
      }
      if (erased) savePageAnnotations();
    }

    async function renderPage(pageNum) {
      if (!pdfDoc) return;
      const page = await pdfDoc.getPage(pageNum);
      const containerRect = container.getBoundingClientRect();
      const viewport = page.getViewport({ scale: 1 });
      pdfPageWidth = viewport.width;
      pdfPageHeight = viewport.height;
      const availableWidth = containerRect.width - 60;
      const pdfScale = (availableWidth * dpr) / viewport.width;
      const scaledViewport = page.getViewport({ scale: pdfScale });
      const displayWidth = availableWidth, displayHeight = scaledViewport.height / dpr;

      pdfCanvas.width = scaledViewport.width;
      pdfCanvas.height = scaledViewport.height;
      pdfCanvas.style.width = displayWidth + 'px';
      pdfCanvas.style.height = displayHeight + 'px';

      const pageContainer = $('pdfPageContainer');
      pageContainer.style.width = displayWidth + 'px';
      pageContainer.style.height = displayHeight + 'px';

      pdfCtx.fillStyle = '#fff';
      pdfCtx.fillRect(0, 0, pdfCanvas.width, pdfCanvas.height);
      await page.render({ canvasContext: pdfCtx, viewport: scaledViewport }).promise;

      svg.setAttribute('viewBox', `0 0 ${pdfPageWidth} ${pdfPageHeight}`);
      svg.style.width = '100%';
      svg.style.height = '100%';

      pageInfo.textContent = `${pageNum} / ${totalPages}`;
      $('prevPage').disabled = pageNum <= 1;
      $('nextPage').disabled = pageNum >= totalPages;
    }

    async function loadPDF(file) {
      loadingOverlay.classList.add('visible');
      try {
        pdfDoc = await pdfjsLib.getDocument({ data: await file.arrayBuffer() }).promise;
        totalPages = pdfDoc.numPages;
        currentPage = 1;
        pageAnnotations = {};
        group.innerHTML = '';
        strokes = [];
        undoStack = [];
        container.classList.remove('no-pdf');
        container.classList.add('pdf-mode');
        pdfControls.classList.add('visible');
        pdfDivider.classList.add('visible');
        hideToolbar();
        await renderPage(1);
        loadPageAnnotations();
        generateFilmstripThumbnails();
      } catch (err) {
        console.log('Error loading PDF:', JSON.stringify(err));
      } finally {
        loadingOverlay.classList.remove('visible');
      }
    }

    function closePDF() {
      pdfDoc = null;
      currentPage = 1;
      totalPages = 0;
      pageAnnotations = {};
      pdfPageWidth = pdfPageHeight = 0;
      pdfCtx.clearRect(0, 0, pdfCanvas.width, pdfCanvas.height);
      group.innerHTML = '';
      strokes = [];
      undoStack = [];
      filmstripContainer.innerHTML = '';
      filmstripThumbnails = [];
      const pageContainer = $('pdfPageContainer');
      pageContainer.style.width = '';
      pageContainer.style.height = '';
      svg.style.width = '100%';
      svg.style.height = '100%';
      const r = container.getBoundingClientRect();
      svg.setAttribute('viewBox', `0 0 ${r.width * dpr} ${r.height * dpr}`);
      container.classList.remove('pdf-mode');
      container.classList.add('no-pdf');
      pdfControls.classList.remove('visible');
      pdfDivider.classList.remove('visible');
    }

    async function goToPage(pageNum, skipAnimation = false) {
      if (!pdfDoc || pageNum < 1 || pageNum > totalPages) return;
      const pageContainer = $('pdfPageContainer');
      if (skipAnimation) {
        savePageAnnotations();
        currentPage = pageNum;
        await renderPage(pageNum);
        loadPageAnnotations();
        container.scrollTop = 0;
        return;
      }
      const direction = pageNum > currentPage ? 'left' : 'right';
      pageContainer.classList.add(`slide-out-${direction}`);
      await new Promise(resolve => setTimeout(resolve, 50));
      savePageAnnotations();
      currentPage = pageNum;
      await renderPage(pageNum);
      loadPageAnnotations();
      container.scrollTop = 0;
      pageContainer.classList.remove(`slide-out-${direction}`);
      pageContainer.classList.add(`slide-in-${direction}`);
      void pageContainer.offsetWidth;
      pageContainer.classList.remove(`slide-in-${direction}`);
    }

    const resize = () => {
      const r = container.getBoundingClientRect();
      if (pdfDoc) renderPage(currentPage);
      else svg.setAttribute('viewBox', `0 0 ${r.width * dpr} ${r.height * dpr}`);
    };

    function generateFilmstripThumbnails() {
      if (!pdfDoc) return;
      filmstripContainer.innerHTML = '';
      filmstripThumbnails = [];
      // Create placeholders immediately (no blocking)
      for (let i = 1; i <= totalPages; i++) {
        const item = document.createElement('div');
        item.className = 'filmstrip-item' + (i === currentPage ? ' active' : '');
        item.dataset.page = i;
        const placeholder = document.createElement('div');
        placeholder.className = 'filmstrip-placeholder';
        placeholder.textContent = `Page ${i}`;
        item.appendChild(placeholder);
        const pageNum = document.createElement('span');
        pageNum.className = 'filmstrip-item-number';
        pageNum.textContent = i;
        item.appendChild(pageNum);
        item.onclick = async () => { hideFilmstrip(); if (i !== currentPage) await goToPage(i, true); };
        filmstripContainer.appendChild(item);
        filmstripThumbnails.push(item);
      }
    }

    async function renderThumbnail(item, pageNum) {
      if (item.dataset.rendered) return;
      const page = await pdfDoc.getPage(pageNum);
      const viewport = page.getViewport({ scale: 1 });
      const scale = 220 / viewport.height;
      const scaledViewport = page.getViewport({ scale });
      const canvas = document.createElement('canvas');
      canvas.width = scaledViewport.width;
      canvas.height = scaledViewport.height;
      await page.render({ canvasContext: canvas.getContext('2d'), viewport: scaledViewport }).promise;
      const placeholder = item.querySelector('.filmstrip-placeholder');
      if (placeholder) placeholder.remove();
      item.insertBefore(canvas, item.firstChild);
      item.dataset.rendered = 'true';
    }

    const showFilmstrip = async () => {
      if (!pdfDoc) return;
      filmstripThumbnails.forEach((item, idx) => item.classList.toggle('active', idx + 1 === currentPage));
      filmstripOverlay.classList.add('visible');
      filmstripContainer.querySelector('.active')?.scrollIntoView({ behavior: 'instant', inline: 'center', block: 'center' });
      // Render thumbnails lazily in background
      for (const item of filmstripThumbnails) {
        if (!item.dataset.rendered) {
          await renderThumbnail(item, parseInt(item.dataset.page));
        }
      }
    };

    const hideFilmstrip = () => filmstripOverlay.classList.remove('visible');

    function handleGestureStart(e) {
      if (e.pointerType !== 'touch' || !pdfDoc) return;
      activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
      if (activePointers.size === 1) { swipeStartX = e.clientX; swipeStartY = e.clientY; }
      else if (activePointers.size === 2) {
        const pts = Array.from(activePointers.values());
        gestureStartDistance = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
      }
    }

    function handleGestureMove(e) {
      if (e.pointerType !== 'touch' || !pdfDoc || !activePointers.has(e.pointerId)) return;
      activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
      if (activePointers.size === 2) {
        const pts = Array.from(activePointers.values());
        if (gestureStartDistance - Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y) > 150) { activePointers.clear(); showFilmstrip(); }
      }
    }

    function handleGestureEnd(e) {
      if (e.pointerType !== 'touch' || !pdfDoc) return;
      if (activePointers.size === 1 && activePointers.has(e.pointerId)) {
        const deltaX = e.clientX - swipeStartX, deltaY = e.clientY - swipeStartY;
        if (Math.abs(deltaX) > 225 && Math.abs(deltaY) < Math.abs(deltaX) * 0.5) goToPage(deltaX > 0 ? currentPage - 1 : currentPage + 1);
      }
      activePointers.delete(e.pointerId);
    }

    menuBtn.onclick = e => { e.stopPropagation(); toggleToolbar(); };
    $('paletteBtn').onclick = e => { e.stopPropagation(); toggleCarousel(); };
    document.addEventListener('pointerdown', e => {
      if (toolbarVisible && !toolbar.contains(e.target) && e.target !== menuBtn) hideToolbar();
      if (carouselVisible && !carousel.contains(e.target) && e.target !== $('paletteBtn') && e.target !== hitarea) hideCarousel();
    });
    toolbar.addEventListener('pointerdown', e => e.stopPropagation());

    $('penTool').onclick = () => setTool('pen');
    $('eraserTool').onclick = () => setTool('eraser');
    $('lassoTool').onclick = () => setTool('lasso');
    $('sizeDown').onclick = () => { if (sizeIdx > 0) { width = sizes[--sizeIdx]; sizeVal.textContent = width; updateCursor(); } };
    $('sizeUp').onclick = () => { if (sizeIdx < sizes.length-1) { width = sizes[++sizeIdx]; sizeVal.textContent = width; updateCursor(); } };
    $('pressureBtn').onclick = () => { pressure = !pressure; $('pressureBtn').classList.toggle('active', pressure); };
    $('undoBtn').onclick = undo;
    $('redoBtn').onclick = redo;
    $('clearBtn').onclick = () => { if (strokes.length) { pushUndo(...strokes.reverse()); strokes = []; group.innerHTML = ''; savePageAnnotations(); } };
    $('fullscreenBtn').onclick = () => {
      if (document.fullscreenElement) document.exitFullscreen();
      else document.documentElement.requestFullscreen();
    };
    $('pdfBtn').onclick = () => pdfInput.click();
    pdfInput.onchange = async e => { if (e.target.files[0]) await loadPDF(e.target.files[0]); pdfInput.value = ''; };
    $('prevPage').onclick = () => goToPage(currentPage - 1);
    $('nextPage').onclick = () => goToPage(currentPage + 1);
    $('closePdf').onclick = closePDF;
    filmstripOverlay.onclick = e => { if (e.target === filmstripOverlay) hideFilmstrip(); };
    container.addEventListener('contextmenu', e => { e.preventDefault(); e.stopPropagation(); return false; });

    container.addEventListener('pointerdown', e => { e.preventDefault(); e.pointerType === 'touch' ? handleGestureStart(e) : start(e); });
    container.addEventListener('pointermove', e => { e.preventDefault(); e.pointerType === 'touch' ? handleGestureMove(e) : move(e); });
    container.addEventListener('pointerup', e => { e.pointerType === 'touch' ? handleGestureEnd(e) : stop(e); });
    container.addEventListener('pointerleave', e => { e.pointerType === 'touch' ? activePointers.delete(e.pointerId) : stop(e); });
    container.addEventListener('pointercancel', e => { e.pointerType === 'touch' ? activePointers.delete(e.pointerId) : stop(e); });
    window.addEventListener('resize', resize);

    document.addEventListener('keydown', e => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); e.shiftKey ? redo() : undo(); }
      if (e.key === 'p' || e.key === 'P') setTool('pen');
      if (e.key === 'e' || e.key === 'E') setTool('eraser');
      if (e.key === 'l' || e.key === 'L') setTool('lasso');
      if (e.key === '[') $('sizeDown').click();
      if (e.key === ']') $('sizeUp').click();
      if (e.key === 'ArrowLeft' && pdfDoc) goToPage(currentPage - 1);
      if (e.key === 'ArrowRight' && pdfDoc) goToPage(currentPage + 1);
      if (e.key === 'f' || e.key === 'F') $('fullscreenBtn').click();
      if ((e.key === 'Delete' || e.key === 'Backspace') && selectedStrokes.length > 0) { e.preventDefault(); deleteSelectedStrokes(); }
      if ((e.ctrlKey || e.metaKey) && e.key === 'd' && selectedStrokes.length > 0) { e.preventDefault(); duplicateSelectedStrokes(); }
    });

    // RAF render loop for smooth drawing
    function renderLoop() {
      if (needsRender && drawing && tool === 'pen' && path && points.length > 0) {
        path.setAttribute('d', buildPath(points, getEffectiveWidth()));
      }
      requestAnimationFrame(renderLoop);
    }
    renderLoop();

    sizeVal.style.color = color;
    updateCursor();
    resize();
  </script>
</body>
</html>
